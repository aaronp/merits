============================================================================================
TypeScript source files from cli/ including implementation files and test files.
============================================================================================



================================================================================
SECTION 1: MAIN CLI FILES
================================================================================

================================================================================
# index.ts
================================================================================

#!/usr/bin/env bun
/**
 * Merits CLI Entry Point
 *
 * Commands:
 * - merits identity new       - Generate new identity
 * - merits identity list      - List identities
 * - merits send               - Send message
 * - merits receive            - Receive messages
 * - merits group create       - Create group
 * - merits group list         - List groups
 *
 * Global options:
 * - --format <json|text|compact>
 * - --verbose
 * - --from <identity>
 * - --config <path>
 * - --convex-url <url>
 * - --no-color
 * - --debug
 */

import { Command } from "commander";
import { loadConfig } from "./lib/config";
import { createVault } from "./lib/vault";
import { createMeritsClient } from "../src/client";
import type { CLIContext } from "./lib/context";

const program = new Command();

program
  .name("merits")
  .description("Merits messaging CLI - KERI-authenticated secure messaging")
  .version("0.1.0");

// Global options
program
  .option("--format <type>", "Output format (json|text|compact)", "text")
  .option("--verbose", "Show detailed envelope data", false)
  .option("--from <aid>", "Identity to use")
  .option("--config <path>", "Config file path")
  .option("--convex-url <url>", "Convex deployment URL")
  .option("--no-color", "Disable colored output")
  .option("--debug", "Enable debug logging");

/**
 * PreAction hook: Initialize context for all commands
 *
 * Creates config, vault, and client once at startup.
 * Injected into command options as `_ctx`.
 */
program.hook("preAction", (thisCommand, actionCommand) => {
  const opts = program.opts();

  // Load config with 4-layer precedence
  const config = loadConfig(opts.config, {
    convexUrl: opts.convexUrl,
    outputFormat: opts.format,
    verbose: opts.verbose,
    color: opts.color,
    defaultIdentity: opts.from,
  });

  // Create vault (OS keychain)
  const vault = createVault();

  // Create Merits client
  const client = createMeritsClient(config.convexUrl);

  // Inject context into command options
  const ctx: CLIContext = { config, vault, client };
  actionCommand.setOptionValue("_ctx", ctx);

  // Debug logging
  if (opts.debug) {
    console.error("[DEBUG] Config:", config);
    console.error("[DEBUG] Vault type: OS Keychain");
  }
});

/**
 * PostAction hook: Cleanup resources
 */
program.hook("postAction", async (thisCommand, actionCommand) => {
  const opts = actionCommand.opts();
  const ctx = opts._ctx as CLIContext | undefined;

  if (ctx) {
    // Flush vault metadata
    await ctx.vault.flush();

    // Close client connection
    ctx.client.close();
  }
});

// --- Commands (placeholders for now) ---

program
  .command("identity")
  .description("Manage identities")
  .action(() => {
    console.log("Identity commands coming soon!");
    console.log("  merits identity new      - Generate new identity");
    console.log("  merits identity list     - List identities");
    console.log("  merits identity show     - Show identity details");
    console.log("  merits identity export   - Export private key");
    console.log("  merits identity delete   - Delete identity");
  });

program
  .command("send")
  .description("Send a message")
  .action(() => {
    console.log("Send command coming in Milestone 2!");
  });

program
  .command("receive")
  .description("Receive messages")
  .action(() => {
    console.log("Receive command coming in Milestone 2!");
  });

program
  .command("group")
  .description("Manage groups")
  .action(() => {
    console.log("Group commands coming in Milestone 3!");
    console.log("  merits group create      - Create group");
    console.log("  merits group list        - List groups");
    console.log("  merits group add-member  - Add member to group");
    console.log("  merits group send        - Send group message");
  });

program
  .command("watch")
  .description("Watch for incoming messages")
  .action(() => {
    console.log("Watch command coming in Milestone 3!");
  });

program
  .command("config")
  .description("Manage configuration")
  .action(() => {
    console.log("Config commands coming soon!");
    console.log("  merits config show       - Show current config");
    console.log("  merits config init       - Initialize config file");
    console.log("  merits config set        - Set config value");
  });

// Parse and execute
program.parse();


================================================================================
SECTION 2: LIBRARY FILES
================================================================================

================================================================================
# lib/config.ts
================================================================================

/**
 * Configuration Management
 *
 * 4-layer precedence: CLI flags > env vars > config file > defaults
 * Config location: ~/.merits/config.json
 * Secure permissions: 0600
 * Schema validation with Ajv
 */

import Ajv from "ajv";
import addFormats from "ajv-formats";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";

/**
 * Configuration schema
 */
export interface MeritsConfig {
  version: number;
  convexUrl?: string;
  outputFormat?: "json" | "text" | "compact";
  watchInterval?: number; // milliseconds
  defaultIdentity?: string;
  verbose?: boolean;
  color?: boolean;
}

/**
 * Config with required convexUrl (after resolution)
 */
export interface ResolvedConfig extends Required<MeritsConfig> {
  convexUrl: string;
}

/**
 * Default configuration
 */
export const DEFAULT_CONFIG: MeritsConfig = {
  version: 1,
  outputFormat: "text",
  watchInterval: 1000,
  verbose: false,
  color: true,
};

/**
 * JSON schema for validation
 */
const CONFIG_SCHEMA = {
  type: "object",
  properties: {
    version: { type: "number", enum: [1] },
    convexUrl: { type: "string", format: "uri" },
    outputFormat: { type: "string", enum: ["json", "text", "compact"] },
    watchInterval: { type: "number", minimum: 100, maximum: 30000 },
    defaultIdentity: { type: "string", minLength: 1 },
    verbose: { type: "boolean" },
    color: { type: "boolean" },
  },
  required: ["version"],
  additionalProperties: false,
};

/**
 * Config validation error
 */
export class ConfigError extends Error {
  constructor(
    message: string,
    public code: "INVALID_SCHEMA" | "FILE_ERROR" | "MISSING_REQUIRED"
  ) {
    super(message);
    this.name = "ConfigError";
  }
}

/**
 * Load configuration with 4-layer precedence
 *
 * @param configPath - Path to config file (default: ~/.merits/config.json)
 * @param overrides - CLI flags and env var overrides
 * @returns Merged and validated configuration
 *
 * @example
 * ```typescript
 * const config = loadConfig('~/.merits/config.json', {
 *   convexUrl: process.env.CONVEX_URL,
 *   outputFormat: opts.format,
 *   verbose: opts.verbose,
 * });
 * ```
 */
export function loadConfig(
  configPath?: string,
  overrides?: Partial<MeritsConfig>
): ResolvedConfig {
  // 1. Start with defaults
  let config: MeritsConfig = { ...DEFAULT_CONFIG };

  // 2. Load from file
  const filePath = resolveConfigPath(configPath);
  if (fs.existsSync(filePath)) {
    try {
      const fileConfig = loadConfigFile(filePath);
      config = { ...config, ...fileConfig };
    } catch (err) {
      if (err instanceof ConfigError) throw err;
      const error = new ConfigError(
        `Failed to load config from ${filePath}: ${err}`,
        "FILE_ERROR"
      );
      throw error;
    }
  }

  // 3. Apply environment variables
  const envConfig = loadEnvConfig();
  config = { ...config, ...envConfig };

  // 4. Apply CLI overrides
  if (overrides) {
    config = { ...config, ...filterUndefined(overrides) };
  }

  // Validate final config
  validateConfig(config);

  // Ensure required fields are present
  if (!config.convexUrl) {
    const error = new ConfigError(
      "convexUrl is required (set via --convex-url, CONVEX_URL env var, or config file)",
      "MISSING_REQUIRED"
    );
    throw error;
  }

  return config as ResolvedConfig;
}

/**
 * Save configuration to file
 *
 * @param config - Configuration to save
 * @param configPath - Path to config file (default: ~/.merits/config.json)
 */
export function saveConfig(
  config: MeritsConfig,
  configPath?: string
): void {
  const filePath = resolveConfigPath(configPath);
  const dir = path.dirname(filePath);

  // Ensure directory exists with secure permissions
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
  }

  // Validate before saving
  validateConfig(config);

  // Write with secure permissions
  const json = JSON.stringify(config, null, 2);
  fs.writeFileSync(filePath, json, { mode: 0o600 });
}

/**
 * Initialize config file with defaults if it doesn't exist
 *
 * @param configPath - Path to config file (default: ~/.merits/config.json)
 * @param initialConfig - Initial configuration values
 */
export function initConfig(
  configPath?: string,
  initialConfig?: Partial<MeritsConfig>
): void {
  const filePath = resolveConfigPath(configPath);

  if (fs.existsSync(filePath)) {
    throw new ConfigError(
      `Config file already exists at ${filePath}`,
      "FILE_ERROR"
    );
  }

  const config: MeritsConfig = {
    ...DEFAULT_CONFIG,
    ...filterUndefined(initialConfig || {}),
  };

  saveConfig(config, filePath);
}

// --- Private helpers ---

/**
 * Resolve config file path
 */
function resolveConfigPath(configPath?: string): string {
  if (configPath) {
    return configPath.startsWith("~")
      ? path.join(os.homedir(), configPath.slice(1))
      : path.resolve(configPath);
  }
  return path.join(os.homedir(), ".merits", "config.json");
}

/**
 * Load config from file
 */
function loadConfigFile(filePath: string): Partial<MeritsConfig> {
  const json = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(json);
}

/**
 * Load config from environment variables
 */
function loadEnvConfig(): Partial<MeritsConfig> {
  const config: Partial<MeritsConfig> = {};

  if (process.env.CONVEX_URL) {
    config.convexUrl = process.env.CONVEX_URL;
  }

  if (process.env.MERITS_OUTPUT_FORMAT) {
    const format = process.env.MERITS_OUTPUT_FORMAT;
    if (format === "json" || format === "text" || format === "compact") {
      config.outputFormat = format;
    }
  }

  if (process.env.MERITS_WATCH_INTERVAL) {
    const interval = parseInt(process.env.MERITS_WATCH_INTERVAL, 10);
    if (!isNaN(interval)) {
      config.watchInterval = interval;
    }
  }

  if (process.env.MERITS_DEFAULT_IDENTITY) {
    config.defaultIdentity = process.env.MERITS_DEFAULT_IDENTITY;
  }

  if (process.env.MERITS_VERBOSE === "true" || process.env.MERITS_VERBOSE === "1") {
    config.verbose = true;
  }

  if (process.env.NO_COLOR === "1" || process.env.NO_COLOR === "true") {
    config.color = false;
  }

  return config;
}

/**
 * Validate config against schema
 */
function validateConfig(config: MeritsConfig): void {
  const ajv = new Ajv({ allErrors: true, strict: false });
  addFormats(ajv); // Add format validators (uri, etc.)
  const validate = ajv.compile(CONFIG_SCHEMA);

  if (!validate(config)) {
    const errors = validate.errors
      ?.map((err) => `${err.instancePath} ${err.message}`)
      .join(", ");
    const error = new ConfigError(
      `Invalid configuration: ${errors}`,
      "INVALID_SCHEMA"
    );
    throw error;
  }
}

/**
 * Filter out undefined values from object
 */
function filterUndefined<T extends Record<string, any>>(obj: T): Partial<T> {
  const result: Partial<T> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (value !== undefined) {
      result[key as keyof T] = value;
    }
  }
  return result;
}


================================================================================
# lib/context.ts
================================================================================

/**
 * CLI Context
 *
 * Shared context for all commands (created by preAction hook).
 * Provides access to config, vault, and client.
 */

import type { MeritsClient } from "../../src/client";
import type { MeritsVault } from "./vault/MeritsVault";
import type { ResolvedConfig } from "./config";

/**
 * CLI context passed to all commands
 */
export interface CLIContext {
  config: ResolvedConfig;
  vault: MeritsVault;
  client: MeritsClient;
}

/**
 * Get context from commander options (set by preAction hook)
 */
export function getContext(opts: any): CLIContext {
  const ctx = opts._ctx as CLIContext | undefined;

  if (!ctx) {
    throw new Error(
      "CLI context not initialized. This is a bug in the CLI framework."
    );
  }

  return ctx;
}


================================================================================
# lib/formatters.ts
================================================================================

/**
 * Output Formatters
 *
 * Three modes: json, text, compact
 * Async signatures for future vault decryption support
 * Colorized output with chalk
 */

import chalk from "chalk";
import type { MeritsVault } from "./vault/MeritsVault";

/**
 * Output format types
 */
export type OutputFormat = "json" | "text" | "compact";

/**
 * Encrypted message structure (from Transport interface)
 */
export interface EncryptedMessage {
  id: string;
  from: string;
  to: string;
  ct: string;
  typ: string;
  ek?: string;
  alg?: string;
  ttlMs: number;
  createdAt: number;
  sig: string[];
  ksn: number;
}

/**
 * Formatter options
 */
export interface FormatOptions {
  verbose?: boolean;
  color?: boolean;
  vault?: MeritsVault;
  identityName?: string;
}

/**
 * Format messages for output
 *
 * @param messages - Array of encrypted messages
 * @param format - Output format (json|text|compact)
 * @param options - Formatting options
 * @returns Formatted string
 *
 * @example
 * ```typescript
 * const output = await formatMessages(messages, 'text', { verbose: true, color: true });
 * console.log(output);
 * ```
 */
export async function formatMessages(
  messages: EncryptedMessage[],
  format: OutputFormat,
  options: FormatOptions = {}
): Promise<string> {
  switch (format) {
    case "json":
      return formatJSON(messages, options);
    case "text":
      return await formatText(messages, options);
    case "compact":
      return await formatCompact(messages, options);
    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

/**
 * Format as JSON
 */
function formatJSON(
  messages: EncryptedMessage[],
  options: FormatOptions
): string {
  if (options.verbose) {
    return JSON.stringify(messages, null, 2);
  }

  // Minimal JSON (no signatures, metadata)
  const minimal = messages.map((msg) => ({
    id: msg.id,
    from: msg.from,
    to: msg.to,
    typ: msg.typ,
    ct: msg.ct,
  }));

  return JSON.stringify(minimal, null, 2);
}

/**
 * Format as human-readable text
 */
async function formatText(
  messages: EncryptedMessage[],
  options: FormatOptions
): Promise<string> {
  const color = options.color ?? true;
  const lines: string[] = [];

  for (const msg of messages) {
    const fromLabel = color ? chalk.blue("From:") : "From:";
    const toLabel = color ? chalk.blue("To:") : "To:";
    const typeLabel = color ? chalk.blue("Type:") : "Type:";
    const timeLabel = color ? chalk.blue("Time:") : "Time:";

    lines.push(`${fromLabel} ${msg.from}`);
    lines.push(`${toLabel} ${msg.to}`);
    lines.push(`${typeLabel} ${msg.typ}`);
    lines.push(`${timeLabel} ${formatTimestamp(msg.createdAt)}`);

    // Decrypt if vault provided
    if (options.vault && options.identityName) {
      try {
        const plaintext = await options.vault.decrypt(
          options.identityName,
          msg.ct,
          { ek: msg.ek, alg: msg.alg }
        );
        const contentLabel = color ? chalk.green("Content:") : "Content:";
        lines.push(`${contentLabel} ${plaintext}`);
      } catch (err) {
        const ctLabel = color ? chalk.yellow("Ciphertext:") : "Ciphertext:";
        lines.push(`${ctLabel} ${truncate(msg.ct, 64)}`);
      }
    } else {
      const ctLabel = color ? chalk.yellow("Ciphertext:") : "Ciphertext:";
      lines.push(`${ctLabel} ${truncate(msg.ct, 64)}`);
    }

    if (options.verbose) {
      const idLabel = color ? chalk.dim("ID:") : "ID:";
      const sigLabel = color ? chalk.dim("Signature:") : "Signature:";
      const ksnLabel = color ? chalk.dim("KSN:") : "KSN:";

      lines.push(`${idLabel} ${msg.id}`);
      lines.push(`${sigLabel} ${msg.sig.join(", ")}`);
      lines.push(`${ksnLabel} ${msg.ksn}`);

      if (msg.ek) {
        const ekLabel = color ? chalk.dim("Ephemeral Key:") : "Ephemeral Key:";
        lines.push(`${ekLabel} ${msg.ek}`);
      }
      if (msg.alg) {
        const algLabel = color ? chalk.dim("Algorithm:") : "Algorithm:";
        lines.push(`${algLabel} ${msg.alg}`);
      }
    }

    lines.push(""); // Blank line between messages
  }

  return lines.join("\n");
}

/**
 * Format as compact one-line-per-message
 */
async function formatCompact(
  messages: EncryptedMessage[],
  options: FormatOptions
): Promise<string> {
  const color = options.color ?? true;
  const lines: string[] = [];

  for (const msg of messages) {
    const time = formatTimestamp(msg.createdAt);
    const from = truncate(msg.from, 12);
    const typ = msg.typ;

    let line: string;

    // Try to decrypt if vault provided
    if (options.vault && options.identityName) {
      try {
        const plaintext = await options.vault.decrypt(
          options.identityName,
          msg.ct,
          { ek: msg.ek, alg: msg.alg }
        );
        const content = truncate(plaintext, 40);
        line = `${time} ${from} [${typ}] ${content}`;
      } catch (err) {
        const ct = truncate(msg.ct, 40);
        line = `${time} ${from} [${typ}] <encrypted: ${ct}>`;
      }
    } else {
      const ct = truncate(msg.ct, 40);
      line = `${time} ${from} [${typ}] <encrypted: ${ct}>`;
    }

    lines.push(color ? chalk.white(line) : line);
  }

  return lines.join("\n");
}

/**
 * Format identity for output
 */
export async function formatIdentity(
  name: string,
  identity: {
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  },
  format: OutputFormat,
  options: FormatOptions = {}
): Promise<string> {
  const color = options.color ?? true;

  switch (format) {
    case "json":
      return JSON.stringify({ name, ...identity }, null, 2);

    case "text": {
      const nameLabel = color ? chalk.blue("Name:") : "Name:";
      const aidLabel = color ? chalk.blue("AID:") : "AID:";
      const ksnLabel = color ? chalk.blue("KSN:") : "KSN:";

      const lines = [
        `${nameLabel} ${name}`,
        `${aidLabel} ${identity.aid}`,
        `${ksnLabel} ${identity.ksn}`,
      ];

      if (identity.metadata && options.verbose) {
        const metaLabel = color ? chalk.blue("Metadata:") : "Metadata:";
        lines.push(`${metaLabel} ${JSON.stringify(identity.metadata, null, 2)}`);
      }

      return lines.join("\n");
    }

    case "compact":
      return `${name} (${truncate(identity.aid, 24)}) KSN=${identity.ksn}`;

    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

/**
 * Format group for output
 */
export async function formatGroup(
  group: {
    id: string;
    name: string;
    members: string[];
    createdAt: number;
  },
  format: OutputFormat,
  options: FormatOptions = {}
): Promise<string> {
  const color = options.color ?? true;

  switch (format) {
    case "json":
      return JSON.stringify(group, null, 2);

    case "text": {
      const idLabel = color ? chalk.blue("ID:") : "ID:";
      const nameLabel = color ? chalk.blue("Name:") : "Name:";
      const membersLabel = color ? chalk.blue("Members:") : "Members:";
      const createdLabel = color ? chalk.blue("Created:") : "Created:";

      const lines = [
        `${idLabel} ${group.id}`,
        `${nameLabel} ${group.name}`,
        `${membersLabel} ${group.members.length}`,
        `${createdLabel} ${formatTimestamp(group.createdAt)}`,
      ];

      if (options.verbose) {
        lines.push("");
        lines.push("Member AIDs:");
        for (const aid of group.members) {
          lines.push(`  - ${aid}`);
        }
      }

      return lines.join("\n");
    }

    case "compact":
      return `${group.name} (${group.members.length} members) - ${formatTimestamp(group.createdAt)}`;

    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

// --- Helpers ---

/**
 * Truncate string with ellipsis
 */
function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength - 3) + "...";
}

/**
 * Format timestamp as human-readable string
 */
function formatTimestamp(ms: number): string {
  const date = new Date(ms);
  return date.toISOString().replace("T", " ").slice(0, 19);
}


================================================================================
# lib/getAuthProof.ts
================================================================================

/**
 * Auth Helper
 *
 * Simplifies authentication for CLI commands.
 * Creates auth proofs using vault + client, with forward-compatible types.
 */

import type { MeritsClient } from "../../src/client";
import type { MeritsVault } from "./vault/MeritsVault";
import type { AuthProof } from "../../core/types";

/**
 * Auth purpose types (forward-compatible)
 */
export type AuthPurpose =
  | "send"
  | "receive"
  | "ack"
  | "receiveAndAck" // Milestone 3: Combined receive + ack
  | "openSession" // Milestone 3: Session tokens
  | "admin"
  | "manageGroup";

/**
 * Get authentication proof for an operation
 *
 * @param params.client - Merits client
 * @param params.vault - Vault for signing
 * @param params.identityName - Identity name in vault
 * @param params.purpose - Auth purpose
 * @param params.args - Operation-specific args
 * @returns AuthProof ready for mutation
 *
 * @example
 * ```typescript
 * const auth = await getAuthProof({
 *   client,
 *   vault,
 *   identityName: 'alice',
 *   purpose: 'send',
 *   args: {
 *     recpAid: bob.aid,
 *     ctHash: client.computeCtHash(ct),
 *     ttl: 60000,
 *     alg: '',
 *     ek: '',
 *   },
 * });
 *
 * await client.transport.sendMessage({ ..., auth });
 * ```
 */
export async function getAuthProof(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  purpose: AuthPurpose;
  args?: Record<string, unknown>;
}): Promise<AuthProof> {
  const { client, vault, identityName, purpose, args = {} } = params;

  // Get identity metadata (no private key)
  const identity = await vault.getIdentity(identityName);

  // Issue challenge
  const challenge = await client.identity.issueChallenge({
    aid: identity.aid,
    purpose: purpose as any, // Cast for now, will be refined in future
    args,
  });

  // Sign payload with vault (key never leaves vault)
  const data = encodePayload(challenge.payloadToSign);
  const sigs = await vault.signIndexed(identityName, data);

  return {
    challengeId: challenge.challengeId,
    sigs,
    ksn: identity.ksn,
  };
}

/**
 * Get session token (Milestone 3 placeholder)
 *
 * Session tokens allow streaming receive + batch ack without
 * issuing a fresh proof for every message.
 *
 * @param params.client - Merits client
 * @param params.vault - Vault for signing
 * @param params.identityName - Identity name in vault
 * @param params.scopes - Token scopes (e.g., ['receive', 'ack'])
 * @param params.ttl - Token lifetime in ms (max 60s)
 * @returns Session token + expiration
 *
 * @throws Error - Not yet implemented
 */
export async function getSessionToken(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  scopes: string[];
  ttl?: number;
}): Promise<{ sessionToken: string; expiresAt: number }> {
  // TODO: Implement in Milestone 3
  throw new Error("Session tokens not yet implemented (Milestone 3)");
}

/**
 * Create combined receiveAndAck proof (Milestone 3 placeholder)
 *
 * Single proof for atomic receive + ack operation.
 *
 * @param params.client - Merits client
 * @param params.vault - Vault for signing
 * @param params.identityName - Identity name in vault
 * @param params.recpAid - Recipient AID
 * @returns AuthProof for receiveAndAck mutation
 *
 * @throws Error - Not yet implemented
 */
export async function getReceiveAndAckProof(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  recpAid: string;
}): Promise<AuthProof> {
  // TODO: Implement in Milestone 3
  throw new Error("receiveAndAck not yet implemented (Milestone 3)");
}

// --- Private helpers ---

/**
 * Encode payload for signing (canonical JSON)
 */
function encodePayload(payload: any): Uint8Array {
  // Sort keys deterministically for canonical encoding
  const sorted = JSON.stringify(
    payload,
    Object.keys(payload).sort()
  );
  return new TextEncoder().encode(sorted);
}


================================================================================
VAULT IMPLEMENTATION
================================================================================

================================================================================
# lib/vault/index.ts
================================================================================

/**
 * Vault Factory
 *
 * Creates appropriate vault implementation based on environment.
 * Future: Add EncryptedFileVault for headless/unsupported systems.
 */

export type { MeritsVault, IdentityMetadata } from "./MeritsVault";
export { VaultError } from "./MeritsVault";
export { OSKeychainVault, setupFlushOnExit } from "./OSKeychainVault";

import { OSKeychainVault, setupFlushOnExit } from "./OSKeychainVault";
import type { MeritsVault } from "./MeritsVault";

/**
 * Create a vault instance
 *
 * @param options.type - Vault type ('keychain' | 'encrypted-file')
 * @param options.meritsDir - Base directory for metadata (default: ~/.merits)
 * @returns MeritsVault implementation
 *
 * @example
 * ```typescript
 * const vault = createVault();
 * setupFlushOnExit(vault); // Auto-flush on process exit
 * ```
 */
export function createVault(options?: {
  type?: "keychain" | "encrypted-file";
  meritsDir?: string;
}): MeritsVault {
  const type = options?.type || "keychain";

  switch (type) {
    case "keychain": {
      const vault = new OSKeychainVault(options?.meritsDir);
      setupFlushOnExit(vault);
      return vault;
    }

    case "encrypted-file":
      // TODO: Implement in future milestone
      throw new Error("EncryptedFileVault not yet implemented");

    default:
      throw new Error(`Unknown vault type: ${type}`);
  }
}


================================================================================
# lib/vault/MeritsVault.ts
================================================================================

/**
 * MeritsVault Interface
 *
 * Abstract interface for secure credential storage.
 * Implementations can use OS keychain, encrypted files, HSM, etc.
 *
 * Design principle: Private keys never leave the vault.
 * All cryptographic operations (signing, decryption) happen inside the vault.
 */

export interface MeritsVault {
  /**
   * Store an identity (AID + private key + metadata)
   *
   * @param name - Human-friendly name for the identity
   * @param identity - Identity data including private key
   */
  storeIdentity(
    name: string,
    identity: {
      aid: string;
      privateKey: Uint8Array;
      ksn: number;
      metadata?: Record<string, any>;
    }
  ): Promise<void>;

  /**
   * Retrieve identity metadata (public data only, no private key)
   *
   * @param name - Identity name
   * @returns Public identity data
   * @throws Error if identity not found
   */
  getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }>;

  /**
   * List all stored identity names
   *
   * @returns Array of identity names
   */
  listIdentities(): Promise<string[]>;

  /**
   * Sign data with indexed signature format (key stays in vault)
   *
   * @param name - Identity name
   * @param data - Data to sign (raw bytes)
   * @returns Indexed signature array (e.g., ["0-<base64url>"])
   * @throws Error if identity not found
   */
  signIndexed(name: string, data: Uint8Array): Promise<string[]>;

  /**
   * Decrypt ciphertext using stored private key (key stays in vault)
   *
   * @param name - Identity name
   * @param ct - Ciphertext (base64)
   * @param opts - Decryption options (algorithm, ephemeral key)
   * @returns Plaintext (string)
   * @throws Error if identity not found or decryption fails
   */
  decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string>;

  /**
   * Export private key (use sparingly, for migration/backup only)
   *
   * @param name - Identity name
   * @returns Raw private key bytes
   * @throws Error if identity not found
   */
  exportPrivateKey(name: string): Promise<Uint8Array>;

  /**
   * Delete an identity (irreversible)
   *
   * @param name - Identity name
   * @throws Error if identity not found
   */
  deleteIdentity(name: string): Promise<void>;

  /**
   * Flush any cached metadata to persistent storage
   *
   * Called automatically on process exit, but can be called manually
   * to ensure durability after critical operations.
   */
  flush(): Promise<void>;
}

/**
 * Identity metadata structure (stored outside vault)
 */
export interface IdentityMetadata {
  version: number;
  identities: Record<
    string,
    {
      aid: string;
      ksn: number;
      metadata?: Record<string, any>;
      createdAt: number;
      updatedAt: number;
    }
  >;
}

/**
 * Vault factory error types
 */
export class VaultError extends Error {
  constructor(
    message: string,
    public code:
      | "NOT_FOUND"
      | "INVALID_KEY"
      | "DECRYPT_FAILED"
      | "STORAGE_ERROR"
      | "ALREADY_EXISTS"
  ) {
    super(message);
    this.name = "VaultError";
  }
}


================================================================================
# lib/vault/OSKeychainVault.ts
================================================================================

/**
 * OSKeychainVault
 *
 * Stores private keys in OS credential store:
 * - macOS: Keychain
 * - Linux: Secret Service API (libsecret)
 * - Windows: Credential Manager
 *
 * Metadata (public data) stored in ~/.merits/identities.json
 * with lazy-loading and flush-on-dirty for performance.
 */

import * as keytar from "keytar";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { signPayload } from "../../../core/crypto";
import type {
  MeritsVault,
  IdentityMetadata,
} from "./MeritsVault";
import { VaultError } from "./MeritsVault";

const SERVICE_NAME = "com.merits.cli";
const METADATA_FILENAME = "identities.json";

export class OSKeychainVault implements MeritsVault {
  private metadataPath: string;
  private metadata: IdentityMetadata | null = null; // Lazy-loaded
  private metadataDirty = false;

  constructor(meritsDir?: string) {
    const baseDir = meritsDir || path.join(os.homedir(), ".merits");
    this.metadataPath = path.join(baseDir, METADATA_FILENAME);

    // Ensure directory exists with secure permissions
    if (!fs.existsSync(baseDir)) {
      fs.mkdirSync(baseDir, { recursive: true, mode: 0o700 });
    }
  }

  /**
   * Store identity with private key in OS keychain
   */
  async storeIdentity(
    name: string,
    identity: {
      aid: string;
      privateKey: Uint8Array;
      ksn: number;
      metadata?: Record<string, any>;
    }
  ): Promise<void> {
    const metadata = this.getMetadata();

    // Check if identity already exists
    if (metadata.identities[name]) {
      throw new VaultError(
        `Identity '${name}' already exists`,
        "ALREADY_EXISTS"
      );
    }

    // Store private key in OS keychain
    const privateKeyBase64 = Buffer.from(identity.privateKey).toString(
      "base64"
    );
    await keytar.setPassword(SERVICE_NAME, name, privateKeyBase64);

    // Store metadata (public data only)
    const now = Date.now();
    metadata.identities[name] = {
      aid: identity.aid,
      ksn: identity.ksn,
      metadata: identity.metadata,
      createdAt: now,
      updatedAt: now,
    };

    this.markDirty();
    await this.flush();
  }

  /**
   * Get identity metadata (no private key)
   */
  async getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }> {
    const metadata = this.getMetadata();
    const identity = metadata.identities[name];

    if (!identity) {
      throw new VaultError(
        `Identity '${name}' not found`,
        "NOT_FOUND"
      );
    }

    return {
      aid: identity.aid,
      ksn: identity.ksn,
      metadata: identity.metadata,
    };
  }

  /**
   * List all identity names
   */
  async listIdentities(): Promise<string[]> {
    const metadata = this.getMetadata();
    return Object.keys(metadata.identities);
  }

  /**
   * Sign data with indexed signature (key stays in keychain)
   */
  async signIndexed(name: string, data: Uint8Array): Promise<string[]> {
    const privateKey = await this.getPrivateKey(name);
    return await signPayload(
      { raw: Buffer.from(data).toString("base64") },
      privateKey,
      0
    );
  }

  /**
   * Decrypt ciphertext (key stays in keychain)
   */
  async decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string> {
    // TODO: Implement ECDH-ES + AES-GCM decryption in Milestone 2
    // For now, placeholder that throws
    throw new Error(
      "Decryption not yet implemented (Milestone 2)"
    );
  }

  /**
   * Export private key (use sparingly)
   */
  async exportPrivateKey(name: string): Promise<Uint8Array> {
    return await this.getPrivateKey(name);
  }

  /**
   * Delete identity from keychain and metadata
   */
  async deleteIdentity(name: string): Promise<void> {
    const metadata = this.getMetadata();

    if (!metadata.identities[name]) {
      throw new VaultError(
        `Identity '${name}' not found`,
        "NOT_FOUND"
      );
    }

    // Delete from keychain
    await keytar.deletePassword(SERVICE_NAME, name);

    // Delete from metadata
    delete metadata.identities[name];
    this.markDirty();
    await this.flush();
  }

  /**
   * Flush metadata to disk if dirty
   */
  async flush(): Promise<void> {
    if (!this.metadataDirty || !this.metadata) {
      return;
    }

    try {
      const json = JSON.stringify(this.metadata, null, 2);
      fs.writeFileSync(this.metadataPath, json, { mode: 0o600 });
      this.metadataDirty = false;
    } catch (err) {
      throw new VaultError(
        `Failed to write metadata: ${err}`,
        "STORAGE_ERROR"
      );
    }
  }

  // --- Private methods ---

  /**
   * Get metadata (lazy-load from disk)
   */
  private getMetadata(): IdentityMetadata {
    if (!this.metadata) {
      this.metadata = this.loadMetadata();
    }
    return this.metadata;
  }

  /**
   * Load metadata from disk
   */
  private loadMetadata(): IdentityMetadata {
    if (!fs.existsSync(this.metadataPath)) {
      return {
        version: 1,
        identities: {},
      };
    }

    try {
      const json = fs.readFileSync(this.metadataPath, "utf-8");
      return JSON.parse(json);
    } catch (err) {
      throw new VaultError(
        `Failed to load metadata: ${err}`,
        "STORAGE_ERROR"
      );
    }
  }

  /**
   * Mark metadata as dirty (needs flush)
   */
  private markDirty(): void {
    this.metadataDirty = true;
  }

  /**
   * Get private key from keychain
   */
  private async getPrivateKey(name: string): Promise<Uint8Array> {
    const privateKeyBase64 = await keytar.getPassword(SERVICE_NAME, name);

    if (!privateKeyBase64) {
      throw new VaultError(
        `Private key for '${name}' not found in keychain`,
        "NOT_FOUND"
      );
    }

    return Buffer.from(privateKeyBase64, "base64");
  }
}

/**
 * Flush vault on process exit (best-effort)
 */
export function setupFlushOnExit(vault: OSKeychainVault): void {
  const handler = async () => {
    try {
      await vault.flush();
    } catch (err) {
      // Ignore errors during shutdown
    }
  };

  process.on("exit", () => {
    handler();
  });
  process.on("SIGINT", () => {
    handler();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    handler();
    process.exit(0);
  });
}


================================================================================
SECTION 3: TEST FILES
================================================================================

================================================================================
# tests/cli/unit/config.test.ts
================================================================================

/**
 * Config Management Tests
 *
 * Tests for configuration loading, validation, and precedence.
 */

import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import {
  loadConfig,
  saveConfig,
  initConfig,
  ConfigError,
  DEFAULT_CONFIG,
} from "../../../cli/lib/config";

describe("Config Management", () => {
  let tempDir: string;
  let configPath: string;

  beforeEach(() => {
    // Create temp directory for tests
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "merits-test-"));
    configPath = path.join(tempDir, "config.json");
  });

  afterEach(() => {
    // Clean up
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }

    // Clean up env vars
    delete process.env.CONVEX_URL;
    delete process.env.MERITS_OUTPUT_FORMAT;
    delete process.env.MERITS_WATCH_INTERVAL;
    delete process.env.MERITS_DEFAULT_IDENTITY;
    delete process.env.MERITS_VERBOSE;
    delete process.env.NO_COLOR;
  });

  test("loads defaults when no config file exists", () => {
    const config = loadConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(config.version).toBe(1);
    expect(config.outputFormat).toBe("text");
    expect(config.watchInterval).toBe(1000);
    expect(config.verbose).toBe(false);
    expect(config.color).toBe(true);
  });

  test("loads config from file", () => {
    const fileConfig = {
      version: 1,
      convexUrl: "https://file.convex.cloud",
      outputFormat: "json" as const,
      watchInterval: 2000,
    };

    fs.writeFileSync(configPath, JSON.stringify(fileConfig, null, 2));

    const config = loadConfig(configPath);

    expect(config.convexUrl).toBe("https://file.convex.cloud");
    expect(config.outputFormat).toBe("json");
    expect(config.watchInterval).toBe(2000);
  });

  test("environment variables override file config", () => {
    const fileConfig = {
      version: 1,
      convexUrl: "https://file.convex.cloud",
      outputFormat: "json" as const,
    };

    fs.writeFileSync(configPath, JSON.stringify(fileConfig, null, 2));

    process.env.CONVEX_URL = "https://env.convex.cloud";
    process.env.MERITS_OUTPUT_FORMAT = "text";

    const config = loadConfig(configPath);

    expect(config.convexUrl).toBe("https://env.convex.cloud");
    expect(config.outputFormat).toBe("text");
  });

  test("CLI flags override everything", () => {
    const fileConfig = {
      version: 1,
      convexUrl: "https://file.convex.cloud",
      outputFormat: "json" as const,
    };

    fs.writeFileSync(configPath, JSON.stringify(fileConfig, null, 2));

    process.env.CONVEX_URL = "https://env.convex.cloud";

    const config = loadConfig(configPath, {
      convexUrl: "https://cli.convex.cloud",
      outputFormat: "compact",
    });

    expect(config.convexUrl).toBe("https://cli.convex.cloud");
    expect(config.outputFormat).toBe("compact");
  });

  test("throws error if convexUrl is missing", () => {
    expect(() => loadConfig(configPath)).toThrow(ConfigError);
  });

  test("validates config schema", () => {
    const invalidConfig = {
      version: 1,
      convexUrl: "https://example.convex.cloud",
      outputFormat: "invalid",
    };

    fs.writeFileSync(configPath, JSON.stringify(invalidConfig, null, 2));

    expect(() => loadConfig(configPath)).toThrow(ConfigError);
  });

  test("validates watchInterval range", () => {
    const invalidConfig = {
      version: 1,
      convexUrl: "https://example.convex.cloud",
      watchInterval: 50, // Too low
    };

    fs.writeFileSync(configPath, JSON.stringify(invalidConfig, null, 2));

    expect(() => loadConfig(configPath)).toThrow(ConfigError);
  });

  test("saves config with secure permissions", () => {
    const config = {
      version: 1,
      convexUrl: "https://example.convex.cloud",
      outputFormat: "text" as const,
    };

    saveConfig(config, configPath);

    expect(fs.existsSync(configPath)).toBe(true);

    // Check permissions (0600)
    const stats = fs.statSync(configPath);
    const mode = stats.mode & 0o777;
    expect(mode).toBe(0o600);

    // Check content
    const saved = JSON.parse(fs.readFileSync(configPath, "utf-8"));
    expect(saved.convexUrl).toBe("https://example.convex.cloud");
  });

  test("initConfig creates config file", () => {
    initConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(fs.existsSync(configPath)).toBe(true);

    const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
    expect(config.version).toBe(1);
    expect(config.convexUrl).toBe("https://example.convex.cloud");
  });

  test("initConfig throws if file already exists", () => {
    initConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(() =>
      initConfig(configPath, {
        convexUrl: "https://example.convex.cloud",
      })
    ).toThrow(ConfigError);
  });

  test("handles malformed JSON in config file", () => {
    fs.writeFileSync(configPath, "{ invalid json }");

    expect(() =>
      loadConfig(configPath, {
        convexUrl: "https://example.convex.cloud",
      })
    ).toThrow();
  });

  test("parses NO_COLOR environment variable", () => {
    process.env.NO_COLOR = "1";

    const config = loadConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(config.color).toBe(false);
  });

  test("parses MERITS_VERBOSE environment variable", () => {
    process.env.MERITS_VERBOSE = "true";

    const config = loadConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(config.verbose).toBe(true);
  });
});


================================================================================
# tests/cli/unit/formatters.test.ts
================================================================================

/**
 * Formatter Tests
 *
 * Tests for output formatters with snapshot tests.
 */

import { describe, test, expect } from "bun:test";
import {
  formatMessages,
  formatIdentity,
  formatGroup,
  type EncryptedMessage,
} from "../../../cli/lib/formatters";

describe("Message Formatters", () => {
  const sampleMessages: EncryptedMessage[] = [
    {
      id: "msg-123",
      from: "EABCDEFabcdef1234567890",
      to: "EXYZabcdef9876543210",
      ct: "aGVsbG8gd29ybGQ=",
      typ: "chat.text.v1",
      ttlMs: 60000,
      createdAt: 1700000000000,
      sig: ["0-abc123def456"],
      ksn: 0,
    },
    {
      id: "msg-456",
      from: "EXYZabcdef9876543210",
      to: "EABCDEFabcdef1234567890",
      ct: "Z29vZGJ5ZSB3b3JsZA==",
      typ: "chat.text.v1",
      ek: "EKephemeral123",
      alg: "ECDH-ES+A256GCM",
      ttlMs: 60000,
      createdAt: 1700001000000,
      sig: ["0-xyz789ghi012"],
      ksn: 1,
    },
  ];

  test("formats as JSON (minimal)", async () => {
    const output = await formatMessages(sampleMessages, "json", {
      verbose: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as JSON (verbose)", async () => {
    const output = await formatMessages(sampleMessages, "json", {
      verbose: true,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as text (no color)", async () => {
    const output = await formatMessages(sampleMessages, "text", {
      color: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as text (verbose, no color)", async () => {
    const output = await formatMessages(sampleMessages, "text", {
      verbose: true,
      color: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as compact (no color)", async () => {
    const output = await formatMessages(sampleMessages, "compact", {
      color: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("throws error for unknown format", async () => {
    await expect(
      formatMessages(sampleMessages, "xml" as any, {})
    ).rejects.toThrow("Unknown format");
  });

  test("handles empty message array", async () => {
    const output = await formatMessages([], "json", {});
    expect(output).toBe("[]");
  });
});

describe("Identity Formatter", () => {
  const sampleIdentity = {
    aid: "EABCDEFabcdef1234567890",
    ksn: 0,
    metadata: {
      email: "alice@example.com",
      createdAt: 1700000000000,
    },
  };

  test("formats identity as JSON", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "json",
      {}
    );

    expect(output).toMatchSnapshot();
  });

  test("formats identity as text (no color)", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "text",
      { color: false }
    );

    expect(output).toMatchSnapshot();
  });

  test("formats identity as text (verbose, no color)", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "text",
      { verbose: true, color: false }
    );

    expect(output).toMatchSnapshot();
  });

  test("formats identity as compact", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "compact",
      {}
    );

    expect(output).toMatchSnapshot();
  });
});

describe("Group Formatter", () => {
  const sampleGroup = {
    id: "grp-123",
    name: "Test Group",
    members: [
      "EABCDEFabcdef1234567890",
      "EXYZabcdef9876543210",
      "E123456789abcdef",
    ],
    createdAt: 1700000000000,
  };

  test("formats group as JSON", async () => {
    const output = await formatGroup(sampleGroup, "json", {});
    expect(output).toMatchSnapshot();
  });

  test("formats group as text (no color)", async () => {
    const output = await formatGroup(sampleGroup, "text", { color: false });
    expect(output).toMatchSnapshot();
  });

  test("formats group as text (verbose, no color)", async () => {
    const output = await formatGroup(sampleGroup, "text", {
      verbose: true,
      color: false,
    });
    expect(output).toMatchSnapshot();
  });

  test("formats group as compact", async () => {
    const output = await formatGroup(sampleGroup, "compact", {});
    expect(output).toMatchSnapshot();
  });
});


================================================================================
# tests/cli/unit/vault.test.ts
================================================================================

/**
 * Vault Tests
 *
 * Tests for OSKeychainVault implementation.
 */

import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { OSKeychainVault } from "../../../cli/lib/vault/OSKeychainVault";
import { VaultError } from "../../../cli/lib/vault/MeritsVault";
import { generateKeyPair, createAID } from "../../../core/crypto";

describe("OSKeychainVault", () => {
  let tempDir: string;
  let vault: OSKeychainVault;

  beforeEach(() => {
    // Create temp directory for tests
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "merits-vault-test-"));
    vault = new OSKeychainVault(tempDir);
  });

  afterEach(async () => {
    // Clean up identities from vault
    const identities = await vault.listIdentities();
    for (const name of identities) {
      try {
        await vault.deleteIdentity(name);
      } catch (err) {
        // Ignore errors during cleanup
      }
    }

    // Clean up temp directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  test("stores and retrieves identity", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
      metadata: { email: "alice@example.com" },
    });

    const identity = await vault.getIdentity("alice");

    expect(identity.aid).toBe(aid);
    expect(identity.ksn).toBe(0);
    expect(identity.metadata?.email).toBe("alice@example.com");
  });

  test("throws error if identity already exists", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await expect(
      vault.storeIdentity("alice", {
        aid,
        privateKey: keys.privateKey,
        ksn: 0,
      })
    ).rejects.toThrow(VaultError);
  });

  test("throws error if identity not found", async () => {
    await expect(vault.getIdentity("nonexistent")).rejects.toThrow(VaultError);
  });

  test("lists all identities", async () => {
    const alice = await generateKeyPair();
    const bob = await generateKeyPair();

    await vault.storeIdentity("alice", {
      aid: createAID(alice.publicKey),
      privateKey: alice.privateKey,
      ksn: 0,
    });

    await vault.storeIdentity("bob", {
      aid: createAID(bob.publicKey),
      privateKey: bob.privateKey,
      ksn: 0,
    });

    const identities = await vault.listIdentities();

    expect(identities).toContain("alice");
    expect(identities).toContain("bob");
    expect(identities.length).toBe(2);
  });

  test("signs data with indexed signature", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    const data = new TextEncoder().encode("test message");
    const sigs = await vault.signIndexed("alice", data);

    expect(sigs.length).toBe(1);
    expect(sigs[0].startsWith("0-")).toBe(true); // Indexed signature
  });

  test("exports private key", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    const exported = await vault.exportPrivateKey("alice");

    expect(exported).toEqual(keys.privateKey);
  });

  test("deletes identity", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.deleteIdentity("alice");

    const identities = await vault.listIdentities();
    expect(identities).not.toContain("alice");
  });

  test("throws error when deleting nonexistent identity", async () => {
    await expect(vault.deleteIdentity("nonexistent")).rejects.toThrow(
      VaultError
    );
  });

  test("metadata file has secure permissions", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.flush();

    const metadataPath = path.join(tempDir, "identities.json");
    const stats = fs.statSync(metadataPath);
    const mode = stats.mode & 0o777;

    expect(mode).toBe(0o600);
  });

  test("flushes metadata on demand", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.flush();

    const metadataPath = path.join(tempDir, "identities.json");
    expect(fs.existsSync(metadataPath)).toBe(true);

    const metadata = JSON.parse(fs.readFileSync(metadataPath, "utf-8"));
    expect(metadata.identities.alice).toBeDefined();
    expect(metadata.identities.alice.aid).toBe(aid);
  });

  test("caches metadata to reduce file I/O", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.flush();

    // Read metadata file mtime
    const metadataPath = path.join(tempDir, "identities.json");
    const mtime1 = fs.statSync(metadataPath).mtimeMs;

    // Get identity multiple times (should use cache)
    await vault.getIdentity("alice");
    await vault.getIdentity("alice");
    await vault.getIdentity("alice");

    // Metadata file should not have been rewritten
    const mtime2 = fs.statSync(metadataPath).mtimeMs;
    expect(mtime1).toBe(mtime2);
  });

  test("handles metadata with no identities", async () => {
    const identities = await vault.listIdentities();
    expect(identities).toEqual([]);
  });

  test("decrypt throws placeholder error", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await expect(
      vault.decrypt("alice", "encrypted-data")
    ).rejects.toThrow("not yet implemented");
  });
});


================================================================================
SECTION 4: DOCUMENTATION
================================================================================

================================================================================
# cli/README.md
================================================================================

# Merits CLI

Command-line interface for Merits messaging system with KERI authentication.

## Quick Start

```bash
# Run all checks (tests + coverage) - default target
make

# Or explicitly
make check

# Run tests only
make test

# View help
make help
```

## Development

### Available Make Targets

- **`make`** or **`make check`** - Run tests + coverage report (default)
- **`make test`** - Run CLI unit tests
- **`make coverage`** - Generate HTML coverage report
- **`make typecheck`** - Type check (currently informational)
- **`make install`** - Install dependencies
- **`make clean`** - Remove generated files
- **`make summarise`** - Generate CLI summary and copy to clipboard
- **`make help`** - Show available targets

### Test Results

Current test coverage (Milestone 0):
- **41/41 tests passing** (100% success rate)
- **85.3% line coverage** overall
- **100% coverage** on config.ts
- **95.65% coverage** on OSKeychainVault.ts
- **86.71% coverage** on formatters.ts

### Project Structure

```
cli/
 Makefile              # Development tasks
 README.md            # This file
 index.ts             # CLI entry point
 lib/
    config.ts        # Configuration management
    context.ts       # CLI context
    formatters.ts    # Output formatters
    getAuthProof.ts  # Auth helper
    vault/
        index.ts            # Vault factory
        MeritsVault.ts      # Vault interface
        OSKeychainVault.ts  # OS Keychain implementation
 tests/
     cli/unit/
         config.test.ts      # Config tests
         formatters.test.ts  # Formatter tests
         vault.test.ts       # Vault tests
```

## Usage

### Running the CLI

```bash
# From project root
bun run cli

# Show help
bun run cli --help

# Example commands (Milestone 1+)
bun run cli identity new alice
bun run cli identity list
bun run cli send --to bob --message "Hello!"
```

### Global Options

- `--format <json|text|compact>` - Output format (default: text)
- `--verbose` - Show detailed envelope data
- `--from <identity>` - Identity to use
- `--config <path>` - Config file path
- `--convex-url <url>` - Convex deployment URL
- `--no-color` - Disable colored output
- `--debug` - Enable debug logging

## Implementation Status

###  Milestone 0 (Complete)

- [x] CLI framework (Commander.js)
- [x] MeritsVault interface
- [x] OSKeychainVault implementation
- [x] Config management (4-layer precedence)
- [x] Output formatters (JSON/text/compact)
- [x] Auth helper (`getAuthProof`)
- [x] Unit tests with 100% pass rate

###  Milestone 1 (Next)

- [ ] `identity new` - Generate new identity
- [ ] `identity list` - List all identities
- [ ] `identity show` - Show identity details
- [ ] `identity export` - Export private key
- [ ] `identity delete` - Delete identity
- [ ] Key rotation ceremony

###  Milestone 2

- [ ] `send` - Send message
- [ ] `receive` - Receive messages
- [ ] Message encryption/decryption

###  Milestone 3

- [ ] `watch` - Watch for incoming messages
- [ ] `group create` - Create group
- [ ] `group` commands - Group management
- [ ] Session tokens

## Architecture

### Vault Design

The vault uses a **pluggable architecture** with OS-native credential storage:

- **Primary**: OS Keychain (macOS/Linux/Windows)
- **Metadata**: `~/.merits/identities.json` (public data, 0600 permissions)
- **Principle**: Private keys never leave the vault
- **Caching**: Lazy-loaded metadata to reduce file I/O

### Config Management

4-layer precedence (highest to lowest):
1. CLI flags
2. Environment variables (`CONVEX_URL`, `MERITS_*`, `NO_COLOR`)
3. Config file (`~/.merits/config.json`)
4. Built-in defaults

### Auth Flow

1. Issue challenge via `client.identity.issueChallenge()`
2. Sign payload with vault (key stays in vault)
3. Return `AuthProof` with signature + challenge ID
4. Submit to mutation

## Dependencies

- **commander** - CLI framework
- **chalk** - Colored output
- **keytar** - OS keychain access
- **ajv** + **ajv-formats** - JSON schema validation
- **ora** - Spinners (future use)

## Documentation

- [CLI Design Plan](../docs/cli-plan.md)
- [Roadmap](../docs/roadmap-cli.md)
- [Milestone 0 Details](../docs/cli-phase-1.md)
- [Milestone 0 Complete](../docs/cli-milestone-0-complete.md)

## Contributing

### Adding New Commands

1. Add command definition in `cli/index.ts`
2. Create command handler in `cli/commands/<name>.ts`
3. Use `getContext(opts)` to access config/vault/client
4. Format output with `formatters.ts`
5. Add tests in `tests/cli/unit/<name>.test.ts`

### Running Tests

```bash
# Run tests
make test

# Watch mode (from project root)
cd .. && bun test --watch tests/cli/unit/

# Coverage
make coverage
open ../coverage/html/index.html
```

## License

See project root LICENSE file.


================================================================================
# docs/cli-phase-1.md
================================================================================

# CLI Milestone 0: Core Infrastructure

**Status**:  In Progress
**Started**: 2025-01-26
**Target Completion**: Week 1
**Actual Completion**: TBD

---

## Overview

Establish the foundational CLI framework, vault abstraction for secure credential management, configuration system, and output formatting. This milestone provides the infrastructure for all subsequent CLI features.

**Related Documentation**:
- [CLI Roadmap](./roadmap-cli.md) - Overall CLI development plan
- [CLI Design Plan](./cli-plan.md) - Comprehensive design
- [CLI Plan (Updated Review)](./merits-cli-plan-updated.md) - Auth optimizations

---

## Goals

### Primary Goals
1.  Set up CLI framework with commander.js
2.  Implement MeritsVault interface with OS Keychain integration
3.  Create configuration management system
4.  Build output formatters (json, text, compact)
5.  Implement auth helper (`getAuthProof`)
6.  Establish project structure

### Secondary Goals
- Unit tests for all core modules
- Documentation for each component
- Error handling patterns
- Logging infrastructure

---

## Architecture

### Project Structure

```
merits/
 cli/
    index.ts                    # Entry point (#!/usr/bin/env bun)
    commands/                   # Command implementations (future)
    lib/
       vault/                  # Credential management
          MeritsVault.ts      # Interface definition
          OSKeychainVault.ts  # OS Keychain implementation
          EncryptedFileVault.ts # Fallback (future)
          index.ts            # Vault factory
       getAuthProof.ts         # Challenge signing helper
       config.ts               # Config management
       formatters.ts           # Output formatting
       client-factory.ts       # Create MeritsClient
    types.ts                    # CLI-specific TypeScript types
 tests/cli/
    unit/                       # Unit tests
    integration/                # Integration tests (future)
 package.json                    # Updated with CLI dependencies
```

---

## Deliverables

### 1. CLI Framework

**File**: `cli/index.ts`

**Purpose**: Entry point for the `merits` binary

**Implementation**:
```typescript
#!/usr/bin/env bun
import { Command } from 'commander';
import { version } from '../package.json';

const program = new Command();

program
  .name('merits')
  .description('Merits messaging CLI - KERI-authenticated secure messaging')
  .version(version);

// Global options
program
  .option('--format <type>', 'Output format (json|text|compact)', 'text')
  .option('--verbose', 'Show detailed envelope data', false)
  .option('--from <aid>', 'Identity to use')
  .option('--config <path>', 'Config file path', '~/.merits/config.json')
  .option('--no-color', 'Disable colored output')
  .option('--debug', 'Enable debug logging');

// Commands will be added in future milestones

program.parse();
```

**Features**:
-  Shebang for direct execution
-  Version flag
-  Global options (format, verbose, etc.)
-  Help text generation
-  Argument parsing

---

### 2. MeritsVault Interface

**File**: `cli/lib/vault/MeritsVault.ts`

**Purpose**: Abstract interface for secure credential management

**Interface Definition**:
```typescript
/**
 * MeritsVault - Secure credential storage abstraction
 *
 * Isolates credential management from the CLI.
 * Private keys never leave the vault.
 */
export interface MeritsVault {
  /**
   * Store a new identity (securely stores private key)
   */
  storeIdentity(name: string, identity: {
    aid: string;
    privateKey: Uint8Array;
    ksn: number;
    metadata?: Record<string, any>;
  }): Promise<void>;

  /**
   * Retrieve identity metadata (NOT private key)
   */
  getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }>;

  /**
   * List all identity names
   */
  listIdentities(): Promise<string[]>;

  /**
   * Sign data with identity's private key
   * Returns KERI indexed signatures (e.g., "0-abc123...")
   * Key never leaves vault
   */
  signIndexed(name: string, data: Uint8Array): Promise<string[]>;

  /**
   * Decrypt ciphertext using identity's private key
   * Key never leaves vault
   */
  decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string>;

  /**
   * Export private key (requires confirmation/authentication)
   * Used for backup/transfer only
   */
  exportPrivateKey(name: string): Promise<Uint8Array>;

  /**
   * Delete an identity
   */
  deleteIdentity(name: string): Promise<void>;
}
```

**Design Principles**:
-  Private keys never exposed directly
-  Signing happens inside vault
-  Decryption happens inside vault
-  Future-proof for multisig (indexed signatures)

---

### 3. OS Keychain Vault Implementation

**File**: `cli/lib/vault/OSKeychainVault.ts`

**Purpose**: Primary vault implementation using OS native credential storage

**Dependencies**:
```json
{
  "keytar": "^7.9.0"  // Cross-platform OS keychain access
}
```

**Implementation**:
```typescript
import * as keytar from 'keytar';
import { sign, verify } from '../../../core/crypto';
import type { MeritsVault } from './MeritsVault';

const SERVICE_NAME = 'com.merits.cli';

/**
 * OSKeychainVault - Stores private keys in OS credential store
 *
 * - macOS: Keychain
 * - Linux: Secret Service API (libsecret)
 * - Windows: Credential Manager
 */
export class OSKeychainVault implements MeritsVault {
  private metadataPath: string;
  private metadata: IdentityMetadata;

  constructor(metadataPath = '~/.merits/identities.json') {
    this.metadataPath = expandPath(metadataPath);
    this.metadata = this.loadMetadata();
  }

  async storeIdentity(name: string, identity: {
    aid: string;
    privateKey: Uint8Array;
    ksn: number;
    metadata?: Record<string, any>;
  }): Promise<void> {
    // Store private key in OS keychain
    const privateKeyHex = Buffer.from(identity.privateKey).toString('hex');
    await keytar.setPassword(SERVICE_NAME, name, privateKeyHex);

    // Store metadata in JSON file (public data only)
    this.metadata.identities[name] = {
      aid: identity.aid,
      ksn: identity.ksn,
      name,
      createdAt: Date.now(),
      vaultProvider: 'os-keychain',
      metadata: identity.metadata
    };

    await this.saveMetadata();
  }

  async getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }> {
    const identity = this.metadata.identities[name];
    if (!identity) {
      throw new Error(`Identity not found: ${name}`);
    }

    return {
      aid: identity.aid,
      ksn: identity.ksn,
      metadata: identity.metadata
    };
  }

  async listIdentities(): Promise<string[]> {
    return Object.keys(this.metadata.identities);
  }

  async signIndexed(name: string, data: Uint8Array): Promise<string[]> {
    const privateKey = await this.getPrivateKey(name);
    const signature = await sign(data, privateKey);

    // Create indexed signature (format: "0-base64sig")
    const sigBase64 = uint8ArrayToBase64Url(signature);
    return [`0-${sigBase64}`];
  }

  async decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string> {
    const privateKey = await this.getPrivateKey(name);

    // For now: simple base64 decoding (mock decryption)
    // Future: X25519 + XChaCha20-Poly1305
    return Buffer.from(ct, 'base64').toString('utf-8');
  }

  async exportPrivateKey(name: string): Promise<Uint8Array> {
    // This should prompt for OS authentication (Touch ID, etc.)
    const privateKey = await this.getPrivateKey(name);
    return privateKey;
  }

  async deleteIdentity(name: string): Promise<void> {
    await keytar.deletePassword(SERVICE_NAME, name);
    delete this.metadata.identities[name];
    await this.saveMetadata();
  }

  // Private helper
  private async getPrivateKey(name: string): Promise<Uint8Array> {
    const privateKeyHex = await keytar.getPassword(SERVICE_NAME, name);
    if (!privateKeyHex) {
      throw new Error(`Private key not found for: ${name}`);
    }
    return Buffer.from(privateKeyHex, 'hex');
  }

  private loadMetadata(): IdentityMetadata {
    if (!fs.existsSync(this.metadataPath)) {
      return { version: 1, defaultIdentity: null, identities: {} };
    }
    return JSON.parse(fs.readFileSync(this.metadataPath, 'utf-8'));
  }

  private async saveMetadata(): Promise<void> {
    const dir = path.dirname(this.metadataPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(
      this.metadataPath,
      JSON.stringify(this.metadata, null, 2),
      { mode: 0o600 }
    );
  }
}
```

**Security Features**:
-  Private keys stored in OS keychain (encrypted by OS)
-  Touch ID / Windows Hello integration (OS-level)
-  Metadata file permissions: 0600 (owner only)
-  No plaintext keys on disk
-  Signing happens in-process (keys retrieved only for operation)

---

### 4. Vault Factory

**File**: `cli/lib/vault/index.ts`

**Purpose**: Auto-detect best vault for platform

**Implementation**:
```typescript
import { OSKeychainVault } from './OSKeychainVault';
import type { MeritsVault } from './MeritsVault';

/**
 * Check if OS keychain is available
 */
function isOSKeychainAvailable(): boolean {
  try {
    require.resolve('keytar');
    return true;
  } catch {
    return false;
  }
}

/**
 * Create vault instance (auto-detect best available)
 */
export function createVault(config?: {
  metadataPath?: string;
}): MeritsVault {
  if (isOSKeychainAvailable()) {
    return new OSKeychainVault(config?.metadataPath);
  }

  // Fallback to encrypted file vault (future)
  console.warn(' OS keychain not available, using encrypted file vault');
  throw new Error('EncryptedFileVault not yet implemented');
}

export type { MeritsVault };
export { OSKeychainVault };
```

---

### 5. Auth Helper

**File**: `cli/lib/getAuthProof.ts`

**Purpose**: Unified helper for KERI challenge signing

**Implementation**:
```typescript
import type { MeritsClient } from '../../src/client';
import type { MeritsVault } from './vault/MeritsVault';
import type { AuthProof } from '../../core/types';

/**
 * Get authentication proof for a Merits operation
 *
 * Handles the complete challenge/response flow:
 * 1. Issue challenge from server
 * 2. Sign payload with vault
 * 3. Return AuthProof
 *
 * @example
 * const auth = await getAuthProof({
 *   client,
 *   vault,
 *   identityName: "alice",
 *   purpose: "send",
 *   args: { recpAid: bobAid, ctHash: "abc123", ttl: 60000 }
 * });
 */
export async function getAuthProof(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  purpose: 'send' | 'receive' | 'ack' | 'receiveAndAck' | 'admin' | 'manageGroup';
  args?: Record<string, unknown>;
}): Promise<AuthProof> {
  const { client, vault, identityName, purpose, args = {} } = params;

  // Get identity metadata
  const identity = await vault.getIdentity(identityName);

  // Issue challenge
  const challenge = await client.identity.issueChallenge({
    aid: identity.aid,
    purpose: purpose as any,
    args
  });

  // Canonical JSON encoding for signing
  const canonical = JSON.stringify(
    challenge.payloadToSign,
    Object.keys(challenge.payloadToSign).sort()
  );
  const data = new TextEncoder().encode(canonical);

  // Sign with vault (key never leaves vault)
  const sigs = await vault.signIndexed(identityName, data);

  return {
    challengeId: challenge.challengeId,
    sigs,
    ksn: identity.ksn
  };
}
```

**Benefits**:
-  Single point for all auth flows
-  Consistent canonical JSON encoding
-  Type-safe purpose parameter
-  Vault abstraction (works with any vault implementation)

---

### 6. Configuration Management

**File**: `cli/lib/config.ts`

**Purpose**: Load/save configuration with precedence

**Config Format** (`~/.merits/config.json`):
```json
{
  "version": 1,
  "convexUrl": "https://accurate-penguin-901.convex.cloud",
  "defaultIdentity": "alice",
  "outputFormat": "text",
  "watchInterval": 1000,
  "autoMarkRead": true,
  "verboseByDefault": false
}
```

**Implementation**:
```typescript
import * as fs from 'fs';
import * as path from 'path';

export interface MeritsConfig {
  version: number;
  convexUrl?: string;
  defaultIdentity?: string;
  outputFormat?: 'json' | 'text' | 'compact';
  watchInterval?: number;
  autoMarkRead?: boolean;
  verboseByDefault?: boolean;
}

const DEFAULT_CONFIG: MeritsConfig = {
  version: 1,
  outputFormat: 'text',
  watchInterval: 1000,
  autoMarkRead: true,
  verboseByDefault: false
};

/**
 * Load configuration with precedence:
 * 1. CLI flags (passed as overrides)
 * 2. Environment variables
 * 3. Config file
 * 4. Built-in defaults
 */
export function loadConfig(
  configPath = '~/.merits/config.json',
  overrides: Partial<MeritsConfig> = {}
): MeritsConfig {
  const expandedPath = expandPath(configPath);

  // Start with defaults
  let config = { ...DEFAULT_CONFIG };

  // Layer 3: Config file
  if (fs.existsSync(expandedPath)) {
    const fileConfig = JSON.parse(fs.readFileSync(expandedPath, 'utf-8'));
    config = { ...config, ...fileConfig };
  }

  // Layer 2: Environment variables
  const envConfig: Partial<MeritsConfig> = {
    convexUrl: process.env.MERITS_CONVEX_URL || process.env.CONVEX_URL,
    defaultIdentity: process.env.MERITS_DEFAULT_IDENTITY,
    outputFormat: process.env.MERITS_FORMAT as any
  };
  config = { ...config, ...envConfig };

  // Layer 1: CLI overrides
  config = { ...config, ...overrides };

  return config;
}

/**
 * Save configuration to file
 */
export function saveConfig(
  config: MeritsConfig,
  configPath = '~/.merits/config.json'
): void {
  const expandedPath = expandPath(configPath);
  const dir = path.dirname(expandedPath);

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(
    expandedPath,
    JSON.stringify(config, null, 2),
    { mode: 0o600 }
  );
}

function expandPath(p: string): string {
  if (p.startsWith('~/')) {
    return path.join(process.env.HOME || '~', p.slice(2));
  }
  return p;
}
```

**Precedence Example**:
```bash
# Config file: outputFormat = "text"
# Env var: MERITS_FORMAT=json
# CLI flag: --format compact

# Result: "compact" (CLI flag wins)
```

---

### 7. Output Formatters

**File**: `cli/lib/formatters.ts`

**Purpose**: Consistent output formatting across all commands

**Implementation**:
```typescript
import chalk from 'chalk';
import type { EncryptedMessage } from '../../core/interfaces/Transport';

export type OutputFormat = 'json' | 'text' | 'compact';

/**
 * Format messages for display
 */
export function formatMessages(
  messages: EncryptedMessage[],
  format: OutputFormat,
  verbose = false
): string {
  switch (format) {
    case 'json':
      return formatJSON(messages, verbose);
    case 'text':
      return formatText(messages, verbose);
    case 'compact':
      return formatCompact(messages);
    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

/**
 * JSON format - machine-readable
 */
function formatJSON(messages: EncryptedMessage[], verbose: boolean): string {
  if (verbose) {
    return JSON.stringify(messages, null, 2);
  }

  // Minimal JSON (exclude senderProof unless verbose)
  const minimal = messages.map(m => ({
    id: m.id,
    from: m.from,
    to: m.to,
    ct: m.ct,
    typ: m.typ,
    createdAt: m.createdAt,
    expiresAt: m.expiresAt
  }));

  return JSON.stringify(minimal, null, 2);
}

/**
 * Text format - human-readable with colors
 */
function formatText(messages: EncryptedMessage[], verbose: boolean): string {
  const lines: string[] = [];

  lines.push(chalk.bold(`${messages.length} message(s)\n`));

  for (const msg of messages) {
    lines.push(chalk.cyan(`From: ${msg.from}`));
    lines.push(chalk.cyan(`To: ${msg.to}`));
    lines.push(`Type: ${msg.typ || 'unknown'}`);
    lines.push(`Time: ${new Date(msg.createdAt).toLocaleString()}`);

    if (verbose) {
      lines.push(`Expires: ${new Date(msg.expiresAt).toLocaleString()}`);
      lines.push('');
      lines.push(chalk.gray('Envelope:'));
      lines.push(chalk.gray(`  ID: ${msg.id}`));
      lines.push(chalk.gray(`  Hash: ${msg.envelopeHash}`));
      lines.push('');
      lines.push(chalk.gray('Sender Proof:'));
      lines.push(chalk.gray(`  KSN: ${msg.senderProof.ksn}`));
      lines.push(chalk.gray(`  Signature: ${msg.senderProof.sigs[0]}`));
    }

    lines.push('');
    lines.push(chalk.white(msg.ct)); // Will be decrypted plaintext in future
    lines.push('');
    lines.push(chalk.gray('---'));
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Compact format - one line per message
 */
function formatCompact(messages: EncryptedMessage[]): string {
  return messages.map(msg => {
    const time = new Date(msg.createdAt).toLocaleTimeString();
    const from = truncateAID(msg.from);
    const to = truncateAID(msg.to);
    const content = msg.ct.substring(0, 50); // Preview
    return `[${time}] ${from}${to}: ${content}`;
  }).join('\n');
}

/**
 * Truncate AID for compact display
 */
function truncateAID(aid: string, length = 8): string {
  if (aid.length <= length) return aid;
  return aid.substring(0, length) + '...';
}
```

**Output Examples**:

**JSON**:
```json
[
  {
    "id": "j5768kc28d1gwe1f9n24xnneyn7t2vbq",
    "from": "DHytGsw0r-wYg0DSf_4l_D594hXtKH_e5-zMIdlM",
    "to": "DXaNTrBG50YwcTLZw2YCkCmKNl2cELpuH-EjDCmdCaXU",
    "ct": "SGVsbG8gQWxpY2Uh",
    "typ": "chat.text.v1",
    "createdAt": 1705329322000,
    "expiresAt": 1705415722000
  }
]
```

**Text**:
```
1 message(s)

From: DHytGsw0r-wYg0DSf_4l_D594hXtKH_e5-zMIdlM
To: DXaNTrBG50YwcTLZw2YCkCmKNl2cELpuH-EjDCmdCaXU
Type: chat.text.v1
Time: 1/15/2024, 2:35:22 PM

Hello Alice!

---
```

**Compact**:
```
[14:35:22] DHytGsw0...DXaNTrBG... Hello Alice!
```

---

## Testing

### Unit Tests

**Location**: `tests/cli/unit/`

**Coverage**:

1. **Vault Tests** (`vault.test.ts`):
```typescript
test("store and retrieve identity metadata", async () => {
  const vault = createVault();

  await vault.storeIdentity("alice", {
    aid: "DHytG...",
    privateKey: new Uint8Array(32),
    ksn: 0
  });

  const identity = await vault.getIdentity("alice");
  expect(identity.aid).toBe("DHytG...");
  expect(identity.ksn).toBe(0);
});

test("sign data with vault", async () => {
  const vault = createVault();
  const data = new TextEncoder().encode("test");

  const sigs = await vault.signIndexed("alice", data);
  expect(sigs).toHaveLength(1);
  expect(sigs[0]).toMatch(/^0-/); // Indexed signature format
});
```

2. **Config Tests** (`config.test.ts`):
```typescript
test("load config with precedence", () => {
  const config = loadConfig('~/.merits/config.json', {
    outputFormat: 'json'
  });

  expect(config.outputFormat).toBe('json'); // Override wins
});
```

3. **Formatter Tests** (`formatters.test.ts`):
```typescript
test("format messages as JSON", () => {
  const messages = [{ id: "msg1", from: "alice", ... }];
  const output = formatMessages(messages, 'json');

  expect(() => JSON.parse(output)).not.toThrow();
});
```

4. **Auth Helper Tests** (`getAuthProof.test.ts`):
```typescript
test("getAuthProof returns valid proof", async () => {
  const proof = await getAuthProof({
    client: mockClient,
    vault: mockVault,
    identityName: "alice",
    purpose: "send",
    args: { recpAid: "bob" }
  });

  expect(proof.challengeId).toBeDefined();
  expect(proof.sigs).toHaveLength(1);
  expect(proof.ksn).toBe(0);
});
```

---

## Success Criteria

### Functional
-  CLI boots with `merits --help`
-  Can create vault and store credentials
-  Can load/save config with precedence
-  Can format output in json/text/compact
-  Can sign challenges via vault
-  All unit tests passing

### Security
-  Private keys stored in OS keychain
-  Metadata file has 0600 permissions
-  Keys never exposed in plaintext
-  Signing happens inside vault

### Code Quality
-  TypeScript strict mode
-  All interfaces documented
-  Error handling consistent
-  Logging infrastructure ready

---

## Dependencies Added

```json
{
  "dependencies": {
    "commander": "^11.1.0",
    "chalk": "^5.3.0",
    "ora": "^8.0.1",
    "keytar": "^7.9.0"
  }
}
```

---

## Next Steps

After Milestone 0 completion:
1. Create completion document
2. Begin Milestone 1 (Identity Management)
3. Implement `merits init` command
4. Implement `merits id:*` commands

---

**Status**:  In Progress
**Completion**: TBD
**Next Milestone**: [Milestone 1: Identity Management](./roadmap-cli.md#milestone-1-identity-management)


================================================================================
# docs/cli-milestone-0-complete.md
================================================================================

# CLI Milestone 0 - Complete 

**Status**: All deliverables implemented and tested
**Test Results**: 41 unit tests passing (100% success rate)
**Date Completed**: 2025-10-26

## Summary

Successfully implemented the foundational infrastructure for the Merits CLI, including:

1.  **CLI Framework** - Commander.js with preAction/postAction hooks
2.  **MeritsVault Interface** - Pluggable credential storage abstraction
3.  **OSKeychainVault** - OS-native keychain integration with metadata caching
4.  **Config Management** - 4-layer precedence with schema validation
5.  **Async Formatters** - JSON/text/compact output with future vault decryption support
6.  **Auth Helper** - `getAuthProof()` with forward-compatible types
7.  **Unit Tests** - 41 tests including error paths and snapshot tests

## Files Created

### Core Infrastructure

```
cli/
 index.ts                     # CLI entry point with commander
 lib/
    context.ts              # CLI context interface
    config.ts               # Config management (243 lines)
    formatters.ts           # Output formatters (284 lines)
    getAuthProof.ts         # Auth helper (108 lines)
    vault/
        MeritsVault.ts      # Vault interface (123 lines)
        OSKeychainVault.ts  # OS Keychain implementation (279 lines)
        index.ts            # Vault factory (49 lines)
```

### Tests

```
tests/cli/unit/
 config.test.ts              # 13 tests for config management
 vault.test.ts               # 13 tests for vault operations
 formatters.test.ts          # 15 tests with snapshots
 __snapshots__/
     formatters.test.ts.snap # 13 golden output snapshots
```

## Test Results

```
 Config Management:          13/13 tests passing
 OSKeychainVault:            13/13 tests passing
 Formatters (with snapshots): 15/15 tests passing

Total:                        41/41 tests passing
Snapshots:                    13 snapshots created
Execution Time:               273ms
```

## Implementation Highlights

### 1. CLI Framework

**File**: [cli/index.ts](../cli/index.ts)

- Commander.js with preAction hook for centralized context setup
- Global options: `--format`, `--verbose`, `--from`, `--config`, `--convex-url`, `--no-color`, `--debug`
- PostAction hook for cleanup (vault flush + client close)
- Placeholder commands for future milestones

**Example Usage**:
```bash
bun run cli/index.ts --help
bun run cli/index.ts identity --verbose
```

### 2. MeritsVault Interface

**File**: [cli/lib/vault/MeritsVault.ts](../cli/lib/vault/MeritsVault.ts)

- **Design Principle**: Private keys never leave the vault
- All crypto operations (signing, decryption) happen inside vault
- Methods: `storeIdentity`, `getIdentity`, `listIdentities`, `signIndexed`, `decrypt`, `exportPrivateKey`, `deleteIdentity`, `flush`
- `VaultError` class with typed error codes

### 3. OSKeychainVault

**File**: [cli/lib/vault/OSKeychainVault.ts](../cli/lib/vault/OSKeychainVault.ts)

**Features**:
- Stores private keys in OS credential store (macOS Keychain, Linux Secret Service, Windows Credential Manager)
- Metadata in `~/.merits/identities.json` (secure permissions: 0600)
- Lazy-loading with metadata caching to reduce file I/O
- Flush-on-dirty pattern with `setupFlushOnExit` helper

**Implementation**:
- Service name: `com.merits.cli`
- Uses `keytar` library for cross-platform OS keychain access
- Private keys stored as base64 in keychain
- Public metadata (AID, KSN, custom fields) stored in JSON file

### 4. Config Management

**File**: [cli/lib/config.ts](../cli/lib/config.ts)

**4-Layer Precedence**:
1. CLI flags (highest priority)
2. Environment variables (`CONVEX_URL`, `MERITS_*`, `NO_COLOR`)
3. Config file (`~/.merits/config.json`)
4. Defaults (lowest priority)

**Schema Validation**:
- Uses Ajv with `ajv-formats` plugin
- Validates types, enums, ranges
- Clear error messages with all validation failures

**Security**:
- Config file created with 0600 permissions
- Config directory created with 0700 permissions

### 5. Async Formatters

**File**: [cli/lib/formatters.ts](../cli/lib/formatters.ts)

**Formats**:
- `json` - Machine-readable (minimal or verbose)
- `text` - Human-readable with color support
- `compact` - One-line-per-item

**Functions**:
- `formatMessages()` - Format encrypted messages
- `formatIdentity()` - Format identity details
- `formatGroup()` - Format group details

**Future-Proof**:
- All formatters are async for future vault decryption
- Accept optional `vault` + `identityName` for auto-decryption
- Color support via `chalk` (respects `--no-color` flag)

### 6. Auth Helper

**File**: [cli/lib/getAuthProof.ts](../cli/lib/getAuthProof.ts)

**Main Function**: `getAuthProof()`
- Simplifies authentication for CLI commands
- Uses vault for signing (key never exported)
- Canonical JSON encoding for deterministic signatures

**Forward-Compatible Types**:
- `AuthPurpose` includes future purposes: `receiveAndAck`, `openSession`
- Placeholder functions: `getSessionToken()`, `getReceiveAndAckProof()`
- Will be implemented in Milestone 3

### 7. Unit Tests

**Coverage**:
-  Config: All precedence layers, validation, error handling
-  Vault: Store/retrieve, list, sign, delete, error paths, metadata caching
-  Formatters: All formats, verbose mode, color mode, snapshot tests

**Error Path Tests**:
- Missing config values
- Invalid schema
- Duplicate identities
- Nonexistent identities
- Malformed JSON
- Unknown formats

**Snapshot Tests**:
- 13 golden output snapshots for formatters
- Ensures consistent output across refactors

## Dependencies Added

```json
{
  "dependencies": {
    "commander": "^11.1.0",    // CLI framework
    "chalk": "^5.3.0",         // Colored output
    "ora": "^8.0.1",           // Spinners (future use)
    "keytar": "^7.9.0",        // OS keychain access
    "ajv": "^8.12.0",          // JSON schema validation
    "ajv-formats": "^3.0.1"    // Format validators (uri, etc.)
  }
}
```

## Architecture Decisions

### 1. Pluggable Vault Design

- Interface-based architecture allows multiple vault implementations
- Factory function (`createVault`) for easy instantiation
- Future: Add `EncryptedFileVault` for headless systems

### 2. Lazy Metadata Loading

- Metadata loaded on first access, not at vault creation
- Reduces startup time for commands that don't need vault
- Flush-on-dirty pattern minimizes writes

### 3. Centralized Context

- PreAction hook creates config/vault/client once
- Injected into command options as `_ctx`
- DRY principle - no duplication across commands

### 4. Forward-Compatible Auth Types

- `AuthPurpose` type includes future purposes
- Placeholder functions throw helpful errors
- No breaking changes when adding session tokens in Milestone 3

## Success Criteria - All Met 

- [x] CLI runs with `--help` and shows usage
- [x] Config loads from all 4 precedence layers
- [x] Config validates against schema
- [x] Vault stores and retrieves identities
- [x] Vault stores private keys in OS keychain
- [x] Vault metadata cached and flushed on demand
- [x] Formatters produce correct output for all 3 modes
- [x] Formatters support async signatures
- [x] Auth helper creates valid proofs
- [x] 41 unit tests pass (100% success rate)
- [x] Snapshot tests verify formatter output

## Next Steps - Milestone 1

See [cli-phase-2.md](cli-phase-2.md) (when created) for:

1. **Identity Commands**:
   - `merits identity new` - Generate new identity
   - `merits identity list` - List all identities
   - `merits identity show` - Show identity details
   - `merits identity export` - Export private key
   - `merits identity delete` - Delete identity

2. **Key Rotation**:
   - Generate rotation event
   - Update keystate on server
   - Migrate to new KSN

3. **Integration Tests**:
   - End-to-end identity management flows
   - Key rotation scenarios

## Notes

- All 7 refinements from [cli-milestone-0-refinements.md](cli-milestone-0-refinements.md) implemented
- Achieved 100% completion as specified in requirements
- Ready to proceed to Milestone 1 (Identity Management)

---

**Milestone 0 Complete** 
All foundational infrastructure in place for building CLI commands.


