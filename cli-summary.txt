============================================================================================
TypeScript source files from cli/ including implementation files and test files.
============================================================================================



================================================================================
SECTION 1: MAIN CLI FILES
================================================================================

================================================================================
# index.ts
================================================================================

#!/usr/bin/env bun
/**
 * Merits CLI Entry Point
 *
 * Commands:
 * - merits identity new       - Generate new identity
 * - merits identity list      - List identities
 * - merits send               - Send message
 * - merits receive            - Receive messages
 * - merits group create       - Create group
 * - merits group list         - List groups
 *
 * Global options:
 * - --format <json|text|compact>
 * - --verbose
 * - --from <identity>
 * - --config <path>
 * - --convex-url <url>
 * - --no-color
 * - --debug
 */

import { Command } from "commander";
import { loadConfig } from "./lib/config";
import { createVault } from "./lib/vault";
import { createMeritsClient } from "../src/client";
import type { CLIContext } from "./lib/context";

const program = new Command();

program
  .name("merits")
  .description("Merits messaging CLI - KERI-authenticated secure messaging")
  .version("0.1.0");

// Global options
program
  .option("--format <type>", "Output format (json|text|compact)", "text")
  .option("--verbose", "Show detailed envelope data", false)
  .option("--from <aid>", "Identity to use")
  .option("--config <path>", "Config file path")
  .option("--convex-url <url>", "Convex deployment URL")
  .option("--no-color", "Disable colored output")
  .option("--debug", "Enable debug logging");

/**
 * PreAction hook: Initialize context for all commands
 *
 * Creates config, vault, and client once at startup.
 * Injected into command options as `_ctx`.
 */
program.hook("preAction", (thisCommand, actionCommand) => {
  const opts = program.opts();

  // Load config with 4-layer precedence
  const config = loadConfig(opts.config, {
    convexUrl: opts.convexUrl,
    outputFormat: opts.format,
    verbose: opts.verbose,
    color: opts.color,
    defaultIdentity: opts.from,
  });

  // Create vault (OS keychain)
  const vault = createVault();

  // Create Merits client
  const client = createMeritsClient(config.convexUrl);

  // Inject context into command options
  const ctx: CLIContext = { config, vault, client };
  actionCommand.setOptionValue("_ctx", ctx);

  // Debug logging
  if (opts.debug) {
    console.error("[DEBUG] Config:", config);
    console.error("[DEBUG] Vault type: OS Keychain");
  }
});

/**
 * PostAction hook: Cleanup resources
 */
program.hook("postAction", async (thisCommand, actionCommand) => {
  const opts = actionCommand.opts();
  const ctx = opts._ctx as CLIContext | undefined;

  if (ctx) {
    // Flush vault metadata
    await ctx.vault.flush();

    // Close client connection
    ctx.client.close();
  }
});

// --- Commands (placeholders for now) ---

program
  .command("identity")
  .description("Manage identities")
  .action(() => {
    console.log("Identity commands coming soon!");
    console.log("  merits identity new      - Generate new identity");
    console.log("  merits identity list     - List identities");
    console.log("  merits identity show     - Show identity details");
    console.log("  merits identity export   - Export private key");
    console.log("  merits identity delete   - Delete identity");
  });

program
  .command("send")
  .description("Send a message")
  .action(() => {
    console.log("Send command coming in Milestone 2!");
  });

program
  .command("receive")
  .description("Receive messages")
  .action(() => {
    console.log("Receive command coming in Milestone 2!");
  });

program
  .command("group")
  .description("Manage groups")
  .action(() => {
    console.log("Group commands coming in Milestone 3!");
    console.log("  merits group create      - Create group");
    console.log("  merits group list        - List groups");
    console.log("  merits group add-member  - Add member to group");
    console.log("  merits group send        - Send group message");
  });

program
  .command("watch")
  .description("Watch for incoming messages")
  .action(() => {
    console.log("Watch command coming in Milestone 3!");
  });

program
  .command("config")
  .description("Manage configuration")
  .action(() => {
    console.log("Config commands coming soon!");
    console.log("  merits config show       - Show current config");
    console.log("  merits config init       - Initialize config file");
    console.log("  merits config set        - Set config value");
  });

// Parse and execute
program.parse();


================================================================================
SECTION 2: LIBRARY FILES
================================================================================

================================================================================
# lib/config.ts
================================================================================

/**
 * Configuration Management
 *
 * 4-layer precedence: CLI flags > env vars > config file > defaults
 * Config location: ~/.merits/config.json
 * Secure permissions: 0600
 * Schema validation with Ajv
 */

import Ajv from "ajv";
import addFormats from "ajv-formats";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";

/**
 * Configuration schema
 */
export interface MeritsConfig {
  version: number;
  convexUrl?: string;
  outputFormat?: "json" | "text" | "compact";
  watchInterval?: number; // milliseconds
  defaultIdentity?: string;
  verbose?: boolean;
  color?: boolean;
}

/**
 * Config with required convexUrl (after resolution)
 */
export interface ResolvedConfig extends Required<MeritsConfig> {
  convexUrl: string;
}

/**
 * Default configuration
 */
export const DEFAULT_CONFIG: MeritsConfig = {
  version: 1,
  outputFormat: "text",
  watchInterval: 1000,
  verbose: false,
  color: true,
};

/**
 * JSON schema for validation
 */
const CONFIG_SCHEMA = {
  type: "object",
  properties: {
    version: { type: "number", enum: [1] },
    convexUrl: { type: "string", format: "uri" },
    outputFormat: { type: "string", enum: ["json", "text", "compact"] },
    watchInterval: { type: "number", minimum: 100, maximum: 30000 },
    defaultIdentity: { type: "string", minLength: 1 },
    verbose: { type: "boolean" },
    color: { type: "boolean" },
  },
  required: ["version"],
  additionalProperties: false,
};

/**
 * Config validation error
 */
export class ConfigError extends Error {
  constructor(
    message: string,
    public code: "INVALID_SCHEMA" | "FILE_ERROR" | "MISSING_REQUIRED"
  ) {
    super(message);
    this.name = "ConfigError";
  }
}

/**
 * Load configuration with 4-layer precedence
 *
 * @param configPath - Path to config file (default: ~/.merits/config.json)
 * @param overrides - CLI flags and env var overrides
 * @returns Merged and validated configuration
 *
 * @example
 * ```typescript
 * const config = loadConfig('~/.merits/config.json', {
 *   convexUrl: process.env.CONVEX_URL,
 *   outputFormat: opts.format,
 *   verbose: opts.verbose,
 * });
 * ```
 */
export function loadConfig(
  configPath?: string,
  overrides?: Partial<MeritsConfig>
): ResolvedConfig {
  // 1. Start with defaults
  let config: MeritsConfig = { ...DEFAULT_CONFIG };

  // 2. Load from file
  const filePath = resolveConfigPath(configPath);
  if (fs.existsSync(filePath)) {
    try {
      const fileConfig = loadConfigFile(filePath);
      config = { ...config, ...fileConfig };
    } catch (err) {
      if (err instanceof ConfigError) throw err;
      const error = new ConfigError(
        `Failed to load config from ${filePath}: ${err}`,
        "FILE_ERROR"
      );
      throw error;
    }
  }

  // 3. Apply environment variables
  const envConfig = loadEnvConfig();
  config = { ...config, ...envConfig };

  // 4. Apply CLI overrides
  if (overrides) {
    config = { ...config, ...filterUndefined(overrides) };
  }

  // Validate final config
  validateConfig(config);

  // Ensure required fields are present
  if (!config.convexUrl) {
    const error = new ConfigError(
      "convexUrl is required (set via --convex-url, CONVEX_URL env var, or config file)",
      "MISSING_REQUIRED"
    );
    throw error;
  }

  return config as ResolvedConfig;
}

/**
 * Save configuration to file
 *
 * @param config - Configuration to save
 * @param configPath - Path to config file (default: ~/.merits/config.json)
 */
export function saveConfig(
  config: MeritsConfig,
  configPath?: string
): void {
  const filePath = resolveConfigPath(configPath);
  const dir = path.dirname(filePath);

  // Ensure directory exists with secure permissions
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true, mode: 0o700 });
  }

  // Validate before saving
  validateConfig(config);

  // Write with secure permissions
  const json = JSON.stringify(config, null, 2);
  fs.writeFileSync(filePath, json, { mode: 0o600 });
}

/**
 * Initialize config file with defaults if it doesn't exist
 *
 * @param configPath - Path to config file (default: ~/.merits/config.json)
 * @param initialConfig - Initial configuration values
 */
export function initConfig(
  configPath?: string,
  initialConfig?: Partial<MeritsConfig>
): void {
  const filePath = resolveConfigPath(configPath);

  if (fs.existsSync(filePath)) {
    throw new ConfigError(
      `Config file already exists at ${filePath}`,
      "FILE_ERROR"
    );
  }

  const config: MeritsConfig = {
    ...DEFAULT_CONFIG,
    ...filterUndefined(initialConfig || {}),
  };

  saveConfig(config, filePath);
}

// --- Private helpers ---

/**
 * Resolve config file path
 */
function resolveConfigPath(configPath?: string): string {
  if (configPath) {
    return configPath.startsWith("~")
      ? path.join(os.homedir(), configPath.slice(1))
      : path.resolve(configPath);
  }
  return path.join(os.homedir(), ".merits", "config.json");
}

/**
 * Load config from file
 */
function loadConfigFile(filePath: string): Partial<MeritsConfig> {
  const json = fs.readFileSync(filePath, "utf-8");
  return JSON.parse(json);
}

/**
 * Load config from environment variables
 */
function loadEnvConfig(): Partial<MeritsConfig> {
  const config: Partial<MeritsConfig> = {};

  if (process.env.CONVEX_URL) {
    config.convexUrl = process.env.CONVEX_URL;
  }

  if (process.env.MERITS_OUTPUT_FORMAT) {
    const format = process.env.MERITS_OUTPUT_FORMAT;
    if (format === "json" || format === "text" || format === "compact") {
      config.outputFormat = format;
    }
  }

  if (process.env.MERITS_WATCH_INTERVAL) {
    const interval = parseInt(process.env.MERITS_WATCH_INTERVAL, 10);
    if (!isNaN(interval)) {
      config.watchInterval = interval;
    }
  }

  if (process.env.MERITS_DEFAULT_IDENTITY) {
    config.defaultIdentity = process.env.MERITS_DEFAULT_IDENTITY;
  }

  if (process.env.MERITS_VERBOSE === "true" || process.env.MERITS_VERBOSE === "1") {
    config.verbose = true;
  }

  if (process.env.NO_COLOR === "1" || process.env.NO_COLOR === "true") {
    config.color = false;
  }

  return config;
}

/**
 * Validate config against schema
 */
function validateConfig(config: MeritsConfig): void {
  const ajv = new Ajv({ allErrors: true, strict: false });
  addFormats(ajv); // Add format validators (uri, etc.)
  const validate = ajv.compile(CONFIG_SCHEMA);

  if (!validate(config)) {
    const errors = validate.errors
      ?.map((err) => `${err.instancePath} ${err.message}`)
      .join(", ");
    const error = new ConfigError(
      `Invalid configuration: ${errors}`,
      "INVALID_SCHEMA"
    );
    throw error;
  }
}

/**
 * Filter out undefined values from object
 */
function filterUndefined<T extends Record<string, any>>(obj: T): Partial<T> {
  const result: Partial<T> = {};
  for (const [key, value] of Object.entries(obj)) {
    if (value !== undefined) {
      result[key as keyof T] = value;
    }
  }
  return result;
}


================================================================================
# lib/context.ts
================================================================================

/**
 * CLI Context
 *
 * Shared context for all commands (created by preAction hook).
 * Provides access to config, vault, and client.
 */

import type { MeritsClient } from "../../src/client";
import type { MeritsVault } from "./vault/MeritsVault";
import type { ResolvedConfig } from "./config";

/**
 * CLI context passed to all commands
 */
export interface CLIContext {
  config: ResolvedConfig;
  vault: MeritsVault;
  client: MeritsClient;
}

/**
 * Get context from commander options (set by preAction hook)
 */
export function getContext(opts: any): CLIContext {
  const ctx = opts._ctx as CLIContext | undefined;

  if (!ctx) {
    throw new Error(
      "CLI context not initialized. This is a bug in the CLI framework."
    );
  }

  return ctx;
}


================================================================================
# lib/formatters.ts
================================================================================

/**
 * Output Formatters
 *
 * Three modes: json, text, compact
 * Async signatures for future vault decryption support
 * Colorized output with chalk
 */

import chalk from "chalk";
import type { MeritsVault } from "./vault/MeritsVault";

/**
 * Output format types
 */
export type OutputFormat = "json" | "text" | "compact";

/**
 * Encrypted message structure (from Transport interface)
 */
export interface EncryptedMessage {
  id: string;
  from: string;
  to: string;
  ct: string;
  typ: string;
  ek?: string;
  alg?: string;
  ttlMs: number;
  createdAt: number;
  sig: string[];
  ksn: number;
}

/**
 * Formatter options
 */
export interface FormatOptions {
  verbose?: boolean;
  color?: boolean;
  vault?: MeritsVault;
  identityName?: string;
}

/**
 * Format messages for output
 *
 * @param messages - Array of encrypted messages
 * @param format - Output format (json|text|compact)
 * @param options - Formatting options
 * @returns Formatted string
 *
 * @example
 * ```typescript
 * const output = await formatMessages(messages, 'text', { verbose: true, color: true });
 * console.log(output);
 * ```
 */
export async function formatMessages(
  messages: EncryptedMessage[],
  format: OutputFormat,
  options: FormatOptions = {}
): Promise<string> {
  switch (format) {
    case "json":
      return formatJSON(messages, options);
    case "text":
      return await formatText(messages, options);
    case "compact":
      return await formatCompact(messages, options);
    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

/**
 * Format as JSON
 */
function formatJSON(
  messages: EncryptedMessage[],
  options: FormatOptions
): string {
  if (options.verbose) {
    return JSON.stringify(messages, null, 2);
  }

  // Minimal JSON (no signatures, metadata)
  const minimal = messages.map((msg) => ({
    id: msg.id,
    from: msg.from,
    to: msg.to,
    typ: msg.typ,
    ct: msg.ct,
  }));

  return JSON.stringify(minimal, null, 2);
}

/**
 * Format as human-readable text
 */
async function formatText(
  messages: EncryptedMessage[],
  options: FormatOptions
): Promise<string> {
  const color = options.color ?? true;
  const lines: string[] = [];

  for (const msg of messages) {
    const fromLabel = color ? chalk.blue("From:") : "From:";
    const toLabel = color ? chalk.blue("To:") : "To:";
    const typeLabel = color ? chalk.blue("Type:") : "Type:";
    const timeLabel = color ? chalk.blue("Time:") : "Time:";

    lines.push(`${fromLabel} ${msg.from}`);
    lines.push(`${toLabel} ${msg.to}`);
    lines.push(`${typeLabel} ${msg.typ}`);
    lines.push(`${timeLabel} ${formatTimestamp(msg.createdAt)}`);

    // Decrypt if vault provided
    if (options.vault && options.identityName) {
      try {
        const plaintext = await options.vault.decrypt(
          options.identityName,
          msg.ct,
          { ek: msg.ek, alg: msg.alg }
        );
        const contentLabel = color ? chalk.green("Content:") : "Content:";
        lines.push(`${contentLabel} ${plaintext}`);
      } catch (err) {
        const ctLabel = color ? chalk.yellow("Ciphertext:") : "Ciphertext:";
        lines.push(`${ctLabel} ${truncate(msg.ct, 64)}`);
      }
    } else {
      const ctLabel = color ? chalk.yellow("Ciphertext:") : "Ciphertext:";
      lines.push(`${ctLabel} ${truncate(msg.ct, 64)}`);
    }

    if (options.verbose) {
      const idLabel = color ? chalk.dim("ID:") : "ID:";
      const sigLabel = color ? chalk.dim("Signature:") : "Signature:";
      const ksnLabel = color ? chalk.dim("KSN:") : "KSN:";

      lines.push(`${idLabel} ${msg.id}`);
      lines.push(`${sigLabel} ${msg.sig.join(", ")}`);
      lines.push(`${ksnLabel} ${msg.ksn}`);

      if (msg.ek) {
        const ekLabel = color ? chalk.dim("Ephemeral Key:") : "Ephemeral Key:";
        lines.push(`${ekLabel} ${msg.ek}`);
      }
      if (msg.alg) {
        const algLabel = color ? chalk.dim("Algorithm:") : "Algorithm:";
        lines.push(`${algLabel} ${msg.alg}`);
      }
    }

    lines.push(""); // Blank line between messages
  }

  return lines.join("\n");
}

/**
 * Format as compact one-line-per-message
 */
async function formatCompact(
  messages: EncryptedMessage[],
  options: FormatOptions
): Promise<string> {
  const color = options.color ?? true;
  const lines: string[] = [];

  for (const msg of messages) {
    const time = formatTimestamp(msg.createdAt);
    const from = truncate(msg.from, 12);
    const typ = msg.typ;

    let line: string;

    // Try to decrypt if vault provided
    if (options.vault && options.identityName) {
      try {
        const plaintext = await options.vault.decrypt(
          options.identityName,
          msg.ct,
          { ek: msg.ek, alg: msg.alg }
        );
        const content = truncate(plaintext, 40);
        line = `${time} ${from} [${typ}] ${content}`;
      } catch (err) {
        const ct = truncate(msg.ct, 40);
        line = `${time} ${from} [${typ}] <encrypted: ${ct}>`;
      }
    } else {
      const ct = truncate(msg.ct, 40);
      line = `${time} ${from} [${typ}] <encrypted: ${ct}>`;
    }

    lines.push(color ? chalk.white(line) : line);
  }

  return lines.join("\n");
}

/**
 * Format identity for output
 */
export async function formatIdentity(
  name: string,
  identity: {
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  },
  format: OutputFormat,
  options: FormatOptions = {}
): Promise<string> {
  const color = options.color ?? true;

  switch (format) {
    case "json":
      return JSON.stringify({ name, ...identity }, null, 2);

    case "text": {
      const nameLabel = color ? chalk.blue("Name:") : "Name:";
      const aidLabel = color ? chalk.blue("AID:") : "AID:";
      const ksnLabel = color ? chalk.blue("KSN:") : "KSN:";

      const lines = [
        `${nameLabel} ${name}`,
        `${aidLabel} ${identity.aid}`,
        `${ksnLabel} ${identity.ksn}`,
      ];

      if (identity.metadata && options.verbose) {
        const metaLabel = color ? chalk.blue("Metadata:") : "Metadata:";
        lines.push(`${metaLabel} ${JSON.stringify(identity.metadata, null, 2)}`);
      }

      return lines.join("\n");
    }

    case "compact":
      return `${name} (${truncate(identity.aid, 24)}) KSN=${identity.ksn}`;

    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

/**
 * Format group for output
 */
export async function formatGroup(
  group: {
    id: string;
    name: string;
    members: string[];
    createdAt: number;
  },
  format: OutputFormat,
  options: FormatOptions = {}
): Promise<string> {
  const color = options.color ?? true;

  switch (format) {
    case "json":
      return JSON.stringify(group, null, 2);

    case "text": {
      const idLabel = color ? chalk.blue("ID:") : "ID:";
      const nameLabel = color ? chalk.blue("Name:") : "Name:";
      const membersLabel = color ? chalk.blue("Members:") : "Members:";
      const createdLabel = color ? chalk.blue("Created:") : "Created:";

      const lines = [
        `${idLabel} ${group.id}`,
        `${nameLabel} ${group.name}`,
        `${membersLabel} ${group.members.length}`,
        `${createdLabel} ${formatTimestamp(group.createdAt)}`,
      ];

      if (options.verbose) {
        lines.push("");
        lines.push("Member AIDs:");
        for (const aid of group.members) {
          lines.push(`  - ${aid}`);
        }
      }

      return lines.join("\n");
    }

    case "compact":
      return `${group.name} (${group.members.length} members) - ${formatTimestamp(group.createdAt)}`;

    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

// --- Helpers ---

/**
 * Truncate string with ellipsis
 */
function truncate(str: string, maxLength: number): string {
  if (str.length <= maxLength) return str;
  return str.slice(0, maxLength - 3) + "...";
}

/**
 * Format timestamp as human-readable string
 */
function formatTimestamp(ms: number): string {
  const date = new Date(ms);
  return date.toISOString().replace("T", " ").slice(0, 19);
}


================================================================================
# lib/getAuthProof.ts
================================================================================

/**
 * Auth Helper
 *
 * Simplifies authentication for CLI commands.
 * Creates auth proofs using vault + client, with forward-compatible types.
 */

import type { MeritsClient } from "../../src/client";
import type { MeritsVault } from "./vault/MeritsVault";
import type { AuthProof } from "../../core/types";

/**
 * Auth purpose types (forward-compatible)
 */
export type AuthPurpose =
  | "send"
  | "receive"
  | "ack"
  | "receiveAndAck" // Milestone 3: Combined receive + ack
  | "openSession" // Milestone 3: Session tokens
  | "admin"
  | "manageGroup";

/**
 * Get authentication proof for an operation
 *
 * @param params.client - Merits client
 * @param params.vault - Vault for signing
 * @param params.identityName - Identity name in vault
 * @param params.purpose - Auth purpose
 * @param params.args - Operation-specific args
 * @returns AuthProof ready for mutation
 *
 * @example
 * ```typescript
 * const auth = await getAuthProof({
 *   client,
 *   vault,
 *   identityName: 'alice',
 *   purpose: 'send',
 *   args: {
 *     recpAid: bob.aid,
 *     ctHash: client.computeCtHash(ct),
 *     ttl: 60000,
 *     alg: '',
 *     ek: '',
 *   },
 * });
 *
 * await client.transport.sendMessage({ ..., auth });
 * ```
 */
export async function getAuthProof(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  purpose: AuthPurpose;
  args?: Record<string, unknown>;
}): Promise<AuthProof> {
  const { client, vault, identityName, purpose, args = {} } = params;

  // Get identity metadata (no private key)
  const identity = await vault.getIdentity(identityName);

  // Issue challenge
  const challenge = await client.identity.issueChallenge({
    aid: identity.aid,
    purpose: purpose as any, // Cast for now, will be refined in future
    args,
  });

  // Sign payload with vault (key never leaves vault)
  const data = encodePayload(challenge.payloadToSign);
  const sigs = await vault.signIndexed(identityName, data);

  return {
    challengeId: challenge.challengeId,
    sigs,
    ksn: identity.ksn,
  };
}

/**
 * Get session token (Milestone 3 placeholder)
 *
 * Session tokens allow streaming receive + batch ack without
 * issuing a fresh proof for every message.
 *
 * @param params.client - Merits client
 * @param params.vault - Vault for signing
 * @param params.identityName - Identity name in vault
 * @param params.scopes - Token scopes (e.g., ['receive', 'ack'])
 * @param params.ttl - Token lifetime in ms (max 60s)
 * @returns Session token + expiration
 *
 * @throws Error - Not yet implemented
 */
export async function getSessionToken(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  scopes: string[];
  ttl?: number;
}): Promise<{ sessionToken: string; expiresAt: number }> {
  // TODO: Implement in Milestone 3
  throw new Error("Session tokens not yet implemented (Milestone 3)");
}

/**
 * Create combined receiveAndAck proof (Milestone 3 placeholder)
 *
 * Single proof for atomic receive + ack operation.
 *
 * @param params.client - Merits client
 * @param params.vault - Vault for signing
 * @param params.identityName - Identity name in vault
 * @param params.recpAid - Recipient AID
 * @returns AuthProof for receiveAndAck mutation
 *
 * @throws Error - Not yet implemented
 */
export async function getReceiveAndAckProof(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  recpAid: string;
}): Promise<AuthProof> {
  // TODO: Implement in Milestone 3
  throw new Error("receiveAndAck not yet implemented (Milestone 3)");
}

// --- Private helpers ---

/**
 * Encode payload for signing (canonical JSON)
 */
function encodePayload(payload: any): Uint8Array {
  // Sort keys deterministically for canonical encoding
  const sorted = JSON.stringify(
    payload,
    Object.keys(payload).sort()
  );
  return new TextEncoder().encode(sorted);
}


================================================================================
VAULT IMPLEMENTATION
================================================================================

================================================================================
# lib/vault/index.ts
================================================================================

/**
 * Vault Factory
 *
 * Creates appropriate vault implementation based on environment.
 * Future: Add EncryptedFileVault for headless/unsupported systems.
 */

export type { MeritsVault, IdentityMetadata } from "./MeritsVault";
export { VaultError } from "./MeritsVault";
export { OSKeychainVault, setupFlushOnExit } from "./OSKeychainVault";

import { OSKeychainVault, setupFlushOnExit } from "./OSKeychainVault";
import type { MeritsVault } from "./MeritsVault";

/**
 * Create a vault instance
 *
 * @param options.type - Vault type ('keychain' | 'encrypted-file')
 * @param options.meritsDir - Base directory for metadata (default: ~/.merits)
 * @returns MeritsVault implementation
 *
 * @example
 * ```typescript
 * const vault = createVault();
 * setupFlushOnExit(vault); // Auto-flush on process exit
 * ```
 */
export function createVault(options?: {
  type?: "keychain" | "encrypted-file";
  meritsDir?: string;
}): MeritsVault {
  const type = options?.type || "keychain";

  switch (type) {
    case "keychain": {
      const vault = new OSKeychainVault(options?.meritsDir);
      setupFlushOnExit(vault);
      return vault;
    }

    case "encrypted-file":
      // TODO: Implement in future milestone
      throw new Error("EncryptedFileVault not yet implemented");

    default:
      throw new Error(`Unknown vault type: ${type}`);
  }
}


================================================================================
# lib/vault/MeritsVault.ts
================================================================================

/**
 * MeritsVault Interface
 *
 * Abstract interface for secure credential storage.
 * Implementations can use OS keychain, encrypted files, HSM, etc.
 *
 * Design principle: Private keys never leave the vault.
 * All cryptographic operations (signing, decryption) happen inside the vault.
 */

export interface MeritsVault {
  /**
   * Store an identity (AID + private key + metadata)
   *
   * @param name - Human-friendly name for the identity
   * @param identity - Identity data including private key
   */
  storeIdentity(
    name: string,
    identity: {
      aid: string;
      privateKey: Uint8Array;
      ksn: number;
      metadata?: Record<string, any>;
    }
  ): Promise<void>;

  /**
   * Retrieve identity metadata (public data only, no private key)
   *
   * @param name - Identity name
   * @returns Public identity data
   * @throws Error if identity not found
   */
  getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }>;

  /**
   * List all stored identity names
   *
   * @returns Array of identity names
   */
  listIdentities(): Promise<string[]>;

  /**
   * Sign data with indexed signature format (key stays in vault)
   *
   * @param name - Identity name
   * @param data - Data to sign (raw bytes)
   * @returns Indexed signature array (e.g., ["0-<base64url>"])
   * @throws Error if identity not found
   */
  signIndexed(name: string, data: Uint8Array): Promise<string[]>;

  /**
   * Decrypt ciphertext using stored private key (key stays in vault)
   *
   * @param name - Identity name
   * @param ct - Ciphertext (base64)
   * @param opts - Decryption options (algorithm, ephemeral key)
   * @returns Plaintext (string)
   * @throws Error if identity not found or decryption fails
   */
  decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string>;

  /**
   * Export private key (use sparingly, for migration/backup only)
   *
   * @param name - Identity name
   * @returns Raw private key bytes
   * @throws Error if identity not found
   */
  exportPrivateKey(name: string): Promise<Uint8Array>;

  /**
   * Delete an identity (irreversible)
   *
   * @param name - Identity name
   * @throws Error if identity not found
   */
  deleteIdentity(name: string): Promise<void>;

  /**
   * Flush any cached metadata to persistent storage
   *
   * Called automatically on process exit, but can be called manually
   * to ensure durability after critical operations.
   */
  flush(): Promise<void>;
}

/**
 * Identity metadata structure (stored outside vault)
 */
export interface IdentityMetadata {
  version: number;
  identities: Record<
    string,
    {
      aid: string;
      ksn: number;
      metadata?: Record<string, any>;
      createdAt: number;
      updatedAt: number;
    }
  >;
}

/**
 * Vault factory error types
 */
export class VaultError extends Error {
  constructor(
    message: string,
    public code:
      | "NOT_FOUND"
      | "INVALID_KEY"
      | "DECRYPT_FAILED"
      | "STORAGE_ERROR"
      | "ALREADY_EXISTS"
  ) {
    super(message);
    this.name = "VaultError";
  }
}


================================================================================
# lib/vault/OSKeychainVault.ts
================================================================================

/**
 * OSKeychainVault
 *
 * Stores private keys in OS credential store:
 * - macOS: Keychain
 * - Linux: Secret Service API (libsecret)
 * - Windows: Credential Manager
 *
 * Metadata (public data) stored in ~/.merits/identities.json
 * with lazy-loading and flush-on-dirty for performance.
 */

import * as keytar from "keytar";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { signPayload } from "../../../core/crypto";
import type {
  MeritsVault,
  IdentityMetadata,
} from "./MeritsVault";
import { VaultError } from "./MeritsVault";

const SERVICE_NAME = "com.merits.cli";
const METADATA_FILENAME = "identities.json";

export class OSKeychainVault implements MeritsVault {
  private metadataPath: string;
  private metadata: IdentityMetadata | null = null; // Lazy-loaded
  private metadataDirty = false;

  constructor(meritsDir?: string) {
    const baseDir = meritsDir || path.join(os.homedir(), ".merits");
    this.metadataPath = path.join(baseDir, METADATA_FILENAME);

    // Ensure directory exists with secure permissions
    if (!fs.existsSync(baseDir)) {
      fs.mkdirSync(baseDir, { recursive: true, mode: 0o700 });
    }
  }

  /**
   * Store identity with private key in OS keychain
   */
  async storeIdentity(
    name: string,
    identity: {
      aid: string;
      privateKey: Uint8Array;
      ksn: number;
      metadata?: Record<string, any>;
    }
  ): Promise<void> {
    const metadata = this.getMetadata();

    // Check if identity already exists
    if (metadata.identities[name]) {
      throw new VaultError(
        `Identity '${name}' already exists`,
        "ALREADY_EXISTS"
      );
    }

    // Store private key in OS keychain
    const privateKeyBase64 = Buffer.from(identity.privateKey).toString(
      "base64"
    );
    await keytar.setPassword(SERVICE_NAME, name, privateKeyBase64);

    // Store metadata (public data only)
    const now = Date.now();
    metadata.identities[name] = {
      aid: identity.aid,
      ksn: identity.ksn,
      metadata: identity.metadata,
      createdAt: now,
      updatedAt: now,
    };

    this.markDirty();
    await this.flush();
  }

  /**
   * Get identity metadata (no private key)
   */
  async getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }> {
    const metadata = this.getMetadata();
    const identity = metadata.identities[name];

    if (!identity) {
      throw new VaultError(
        `Identity '${name}' not found`,
        "NOT_FOUND"
      );
    }

    return {
      aid: identity.aid,
      ksn: identity.ksn,
      metadata: identity.metadata,
    };
  }

  /**
   * List all identity names
   */
  async listIdentities(): Promise<string[]> {
    const metadata = this.getMetadata();
    return Object.keys(metadata.identities);
  }

  /**
   * Sign data with indexed signature (key stays in keychain)
   */
  async signIndexed(name: string, data: Uint8Array): Promise<string[]> {
    const privateKey = await this.getPrivateKey(name);
    return await signPayload(
      { raw: Buffer.from(data).toString("base64") },
      privateKey,
      0
    );
  }

  /**
   * Decrypt ciphertext (key stays in keychain)
   */
  async decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string> {
    // TODO: Implement ECDH-ES + AES-GCM decryption in Milestone 2
    // For now, placeholder that throws
    throw new Error(
      "Decryption not yet implemented (Milestone 2)"
    );
  }

  /**
   * Export private key (use sparingly)
   */
  async exportPrivateKey(name: string): Promise<Uint8Array> {
    return await this.getPrivateKey(name);
  }

  /**
   * Delete identity from keychain and metadata
   */
  async deleteIdentity(name: string): Promise<void> {
    const metadata = this.getMetadata();

    if (!metadata.identities[name]) {
      throw new VaultError(
        `Identity '${name}' not found`,
        "NOT_FOUND"
      );
    }

    // Delete from keychain
    await keytar.deletePassword(SERVICE_NAME, name);

    // Delete from metadata
    delete metadata.identities[name];
    this.markDirty();
    await this.flush();
  }

  /**
   * Flush metadata to disk if dirty
   */
  async flush(): Promise<void> {
    if (!this.metadataDirty || !this.metadata) {
      return;
    }

    try {
      const json = JSON.stringify(this.metadata, null, 2);
      fs.writeFileSync(this.metadataPath, json, { mode: 0o600 });
      this.metadataDirty = false;
    } catch (err) {
      throw new VaultError(
        `Failed to write metadata: ${err}`,
        "STORAGE_ERROR"
      );
    }
  }

  // --- Private methods ---

  /**
   * Get metadata (lazy-load from disk)
   */
  private getMetadata(): IdentityMetadata {
    if (!this.metadata) {
      this.metadata = this.loadMetadata();
    }
    return this.metadata;
  }

  /**
   * Load metadata from disk
   */
  private loadMetadata(): IdentityMetadata {
    if (!fs.existsSync(this.metadataPath)) {
      return {
        version: 1,
        identities: {},
      };
    }

    try {
      const json = fs.readFileSync(this.metadataPath, "utf-8");
      return JSON.parse(json);
    } catch (err) {
      throw new VaultError(
        `Failed to load metadata: ${err}`,
        "STORAGE_ERROR"
      );
    }
  }

  /**
   * Mark metadata as dirty (needs flush)
   */
  private markDirty(): void {
    this.metadataDirty = true;
  }

  /**
   * Get private key from keychain
   */
  private async getPrivateKey(name: string): Promise<Uint8Array> {
    const privateKeyBase64 = await keytar.getPassword(SERVICE_NAME, name);

    if (!privateKeyBase64) {
      throw new VaultError(
        `Private key for '${name}' not found in keychain`,
        "NOT_FOUND"
      );
    }

    return Buffer.from(privateKeyBase64, "base64");
  }
}

/**
 * Flush vault on process exit (best-effort)
 */
export function setupFlushOnExit(vault: OSKeychainVault): void {
  const handler = async () => {
    try {
      await vault.flush();
    } catch (err) {
      // Ignore errors during shutdown
    }
  };

  process.on("exit", () => {
    handler();
  });
  process.on("SIGINT", () => {
    handler();
    process.exit(0);
  });
  process.on("SIGTERM", () => {
    handler();
    process.exit(0);
  });
}


================================================================================
SECTION 3: TEST FILES
================================================================================

================================================================================
# tests/cli/unit/config.test.ts
================================================================================

/**
 * Config Management Tests
 *
 * Tests for configuration loading, validation, and precedence.
 */

import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import {
  loadConfig,
  saveConfig,
  initConfig,
  ConfigError,
  DEFAULT_CONFIG,
} from "../../../cli/lib/config";

describe("Config Management", () => {
  let tempDir: string;
  let configPath: string;

  beforeEach(() => {
    // Create temp directory for tests
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "merits-test-"));
    configPath = path.join(tempDir, "config.json");
  });

  afterEach(() => {
    // Clean up
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }

    // Clean up env vars
    delete process.env.CONVEX_URL;
    delete process.env.MERITS_OUTPUT_FORMAT;
    delete process.env.MERITS_WATCH_INTERVAL;
    delete process.env.MERITS_DEFAULT_IDENTITY;
    delete process.env.MERITS_VERBOSE;
    delete process.env.NO_COLOR;
  });

  test("loads defaults when no config file exists", () => {
    const config = loadConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(config.version).toBe(1);
    expect(config.outputFormat).toBe("text");
    expect(config.watchInterval).toBe(1000);
    expect(config.verbose).toBe(false);
    expect(config.color).toBe(true);
  });

  test("loads config from file", () => {
    const fileConfig = {
      version: 1,
      convexUrl: "https://file.convex.cloud",
      outputFormat: "json" as const,
      watchInterval: 2000,
    };

    fs.writeFileSync(configPath, JSON.stringify(fileConfig, null, 2));

    const config = loadConfig(configPath);

    expect(config.convexUrl).toBe("https://file.convex.cloud");
    expect(config.outputFormat).toBe("json");
    expect(config.watchInterval).toBe(2000);
  });

  test("environment variables override file config", () => {
    const fileConfig = {
      version: 1,
      convexUrl: "https://file.convex.cloud",
      outputFormat: "json" as const,
    };

    fs.writeFileSync(configPath, JSON.stringify(fileConfig, null, 2));

    process.env.CONVEX_URL = "https://env.convex.cloud";
    process.env.MERITS_OUTPUT_FORMAT = "text";

    const config = loadConfig(configPath);

    expect(config.convexUrl).toBe("https://env.convex.cloud");
    expect(config.outputFormat).toBe("text");
  });

  test("CLI flags override everything", () => {
    const fileConfig = {
      version: 1,
      convexUrl: "https://file.convex.cloud",
      outputFormat: "json" as const,
    };

    fs.writeFileSync(configPath, JSON.stringify(fileConfig, null, 2));

    process.env.CONVEX_URL = "https://env.convex.cloud";

    const config = loadConfig(configPath, {
      convexUrl: "https://cli.convex.cloud",
      outputFormat: "compact",
    });

    expect(config.convexUrl).toBe("https://cli.convex.cloud");
    expect(config.outputFormat).toBe("compact");
  });

  test("throws error if convexUrl is missing", () => {
    expect(() => loadConfig(configPath)).toThrow(ConfigError);
  });

  test("validates config schema", () => {
    const invalidConfig = {
      version: 1,
      convexUrl: "https://example.convex.cloud",
      outputFormat: "invalid",
    };

    fs.writeFileSync(configPath, JSON.stringify(invalidConfig, null, 2));

    expect(() => loadConfig(configPath)).toThrow(ConfigError);
  });

  test("validates watchInterval range", () => {
    const invalidConfig = {
      version: 1,
      convexUrl: "https://example.convex.cloud",
      watchInterval: 50, // Too low
    };

    fs.writeFileSync(configPath, JSON.stringify(invalidConfig, null, 2));

    expect(() => loadConfig(configPath)).toThrow(ConfigError);
  });

  test("saves config with secure permissions", () => {
    const config = {
      version: 1,
      convexUrl: "https://example.convex.cloud",
      outputFormat: "text" as const,
    };

    saveConfig(config, configPath);

    expect(fs.existsSync(configPath)).toBe(true);

    // Check permissions (0600)
    const stats = fs.statSync(configPath);
    const mode = stats.mode & 0o777;
    expect(mode).toBe(0o600);

    // Check content
    const saved = JSON.parse(fs.readFileSync(configPath, "utf-8"));
    expect(saved.convexUrl).toBe("https://example.convex.cloud");
  });

  test("initConfig creates config file", () => {
    initConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(fs.existsSync(configPath)).toBe(true);

    const config = JSON.parse(fs.readFileSync(configPath, "utf-8"));
    expect(config.version).toBe(1);
    expect(config.convexUrl).toBe("https://example.convex.cloud");
  });

  test("initConfig throws if file already exists", () => {
    initConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(() =>
      initConfig(configPath, {
        convexUrl: "https://example.convex.cloud",
      })
    ).toThrow(ConfigError);
  });

  test("handles malformed JSON in config file", () => {
    fs.writeFileSync(configPath, "{ invalid json }");

    expect(() =>
      loadConfig(configPath, {
        convexUrl: "https://example.convex.cloud",
      })
    ).toThrow();
  });

  test("parses NO_COLOR environment variable", () => {
    process.env.NO_COLOR = "1";

    const config = loadConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(config.color).toBe(false);
  });

  test("parses MERITS_VERBOSE environment variable", () => {
    process.env.MERITS_VERBOSE = "true";

    const config = loadConfig(configPath, {
      convexUrl: "https://example.convex.cloud",
    });

    expect(config.verbose).toBe(true);
  });
});


================================================================================
# tests/cli/unit/formatters.test.ts
================================================================================

/**
 * Formatter Tests
 *
 * Tests for output formatters with snapshot tests.
 */

import { describe, test, expect } from "bun:test";
import {
  formatMessages,
  formatIdentity,
  formatGroup,
  type EncryptedMessage,
} from "../../../cli/lib/formatters";

describe("Message Formatters", () => {
  const sampleMessages: EncryptedMessage[] = [
    {
      id: "msg-123",
      from: "EABCDEFabcdef1234567890",
      to: "EXYZabcdef9876543210",
      ct: "aGVsbG8gd29ybGQ=",
      typ: "chat.text.v1",
      ttlMs: 60000,
      createdAt: 1700000000000,
      sig: ["0-abc123def456"],
      ksn: 0,
    },
    {
      id: "msg-456",
      from: "EXYZabcdef9876543210",
      to: "EABCDEFabcdef1234567890",
      ct: "Z29vZGJ5ZSB3b3JsZA==",
      typ: "chat.text.v1",
      ek: "EKephemeral123",
      alg: "ECDH-ES+A256GCM",
      ttlMs: 60000,
      createdAt: 1700001000000,
      sig: ["0-xyz789ghi012"],
      ksn: 1,
    },
  ];

  test("formats as JSON (minimal)", async () => {
    const output = await formatMessages(sampleMessages, "json", {
      verbose: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as JSON (verbose)", async () => {
    const output = await formatMessages(sampleMessages, "json", {
      verbose: true,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as text (no color)", async () => {
    const output = await formatMessages(sampleMessages, "text", {
      color: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as text (verbose, no color)", async () => {
    const output = await formatMessages(sampleMessages, "text", {
      verbose: true,
      color: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("formats as compact (no color)", async () => {
    const output = await formatMessages(sampleMessages, "compact", {
      color: false,
    });

    expect(output).toMatchSnapshot();
  });

  test("throws error for unknown format", async () => {
    await expect(
      formatMessages(sampleMessages, "xml" as any, {})
    ).rejects.toThrow("Unknown format");
  });

  test("handles empty message array", async () => {
    const output = await formatMessages([], "json", {});
    expect(output).toBe("[]");
  });
});

describe("Identity Formatter", () => {
  const sampleIdentity = {
    aid: "EABCDEFabcdef1234567890",
    ksn: 0,
    metadata: {
      email: "alice@example.com",
      createdAt: 1700000000000,
    },
  };

  test("formats identity as JSON", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "json",
      {}
    );

    expect(output).toMatchSnapshot();
  });

  test("formats identity as text (no color)", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "text",
      { color: false }
    );

    expect(output).toMatchSnapshot();
  });

  test("formats identity as text (verbose, no color)", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "text",
      { verbose: true, color: false }
    );

    expect(output).toMatchSnapshot();
  });

  test("formats identity as compact", async () => {
    const output = await formatIdentity(
      "alice",
      sampleIdentity,
      "compact",
      {}
    );

    expect(output).toMatchSnapshot();
  });
});

describe("Group Formatter", () => {
  const sampleGroup = {
    id: "grp-123",
    name: "Test Group",
    members: [
      "EABCDEFabcdef1234567890",
      "EXYZabcdef9876543210",
      "E123456789abcdef",
    ],
    createdAt: 1700000000000,
  };

  test("formats group as JSON", async () => {
    const output = await formatGroup(sampleGroup, "json", {});
    expect(output).toMatchSnapshot();
  });

  test("formats group as text (no color)", async () => {
    const output = await formatGroup(sampleGroup, "text", { color: false });
    expect(output).toMatchSnapshot();
  });

  test("formats group as text (verbose, no color)", async () => {
    const output = await formatGroup(sampleGroup, "text", {
      verbose: true,
      color: false,
    });
    expect(output).toMatchSnapshot();
  });

  test("formats group as compact", async () => {
    const output = await formatGroup(sampleGroup, "compact", {});
    expect(output).toMatchSnapshot();
  });
});


================================================================================
# tests/cli/unit/vault.test.ts
================================================================================

/**
 * Vault Tests
 *
 * Tests for OSKeychainVault implementation.
 */

import { describe, test, expect, beforeEach, afterEach } from "bun:test";
import * as fs from "fs";
import * as path from "path";
import * as os from "os";
import { OSKeychainVault } from "../../../cli/lib/vault/OSKeychainVault";
import { VaultError } from "../../../cli/lib/vault/MeritsVault";
import { generateKeyPair, createAID } from "../../../core/crypto";

describe("OSKeychainVault", () => {
  let tempDir: string;
  let vault: OSKeychainVault;

  beforeEach(() => {
    // Create temp directory for tests
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), "merits-vault-test-"));
    vault = new OSKeychainVault(tempDir);
  });

  afterEach(async () => {
    // Clean up identities from vault
    const identities = await vault.listIdentities();
    for (const name of identities) {
      try {
        await vault.deleteIdentity(name);
      } catch (err) {
        // Ignore errors during cleanup
      }
    }

    // Clean up temp directory
    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });

  test("stores and retrieves identity", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
      metadata: { email: "alice@example.com" },
    });

    const identity = await vault.getIdentity("alice");

    expect(identity.aid).toBe(aid);
    expect(identity.ksn).toBe(0);
    expect(identity.metadata?.email).toBe("alice@example.com");
  });

  test("throws error if identity already exists", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await expect(
      vault.storeIdentity("alice", {
        aid,
        privateKey: keys.privateKey,
        ksn: 0,
      })
    ).rejects.toThrow(VaultError);
  });

  test("throws error if identity not found", async () => {
    await expect(vault.getIdentity("nonexistent")).rejects.toThrow(VaultError);
  });

  test("lists all identities", async () => {
    const alice = await generateKeyPair();
    const bob = await generateKeyPair();

    await vault.storeIdentity("alice", {
      aid: createAID(alice.publicKey),
      privateKey: alice.privateKey,
      ksn: 0,
    });

    await vault.storeIdentity("bob", {
      aid: createAID(bob.publicKey),
      privateKey: bob.privateKey,
      ksn: 0,
    });

    const identities = await vault.listIdentities();

    expect(identities).toContain("alice");
    expect(identities).toContain("bob");
    expect(identities.length).toBe(2);
  });

  test("signs data with indexed signature", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    const data = new TextEncoder().encode("test message");
    const sigs = await vault.signIndexed("alice", data);

    expect(sigs.length).toBe(1);
    expect(sigs[0].startsWith("0-")).toBe(true); // Indexed signature
  });

  test("exports private key", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    const exported = await vault.exportPrivateKey("alice");

    expect(exported).toEqual(keys.privateKey);
  });

  test("deletes identity", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.deleteIdentity("alice");

    const identities = await vault.listIdentities();
    expect(identities).not.toContain("alice");
  });

  test("throws error when deleting nonexistent identity", async () => {
    await expect(vault.deleteIdentity("nonexistent")).rejects.toThrow(
      VaultError
    );
  });

  test("metadata file has secure permissions", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.flush();

    const metadataPath = path.join(tempDir, "identities.json");
    const stats = fs.statSync(metadataPath);
    const mode = stats.mode & 0o777;

    expect(mode).toBe(0o600);
  });

  test("flushes metadata on demand", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.flush();

    const metadataPath = path.join(tempDir, "identities.json");
    expect(fs.existsSync(metadataPath)).toBe(true);

    const metadata = JSON.parse(fs.readFileSync(metadataPath, "utf-8"));
    expect(metadata.identities.alice).toBeDefined();
    expect(metadata.identities.alice.aid).toBe(aid);
  });

  test("caches metadata to reduce file I/O", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await vault.flush();

    // Read metadata file mtime
    const metadataPath = path.join(tempDir, "identities.json");
    const mtime1 = fs.statSync(metadataPath).mtimeMs;

    // Get identity multiple times (should use cache)
    await vault.getIdentity("alice");
    await vault.getIdentity("alice");
    await vault.getIdentity("alice");

    // Metadata file should not have been rewritten
    const mtime2 = fs.statSync(metadataPath).mtimeMs;
    expect(mtime1).toBe(mtime2);
  });

  test("handles metadata with no identities", async () => {
    const identities = await vault.listIdentities();
    expect(identities).toEqual([]);
  });

  test("decrypt throws placeholder error", async () => {
    const keys = await generateKeyPair();
    const aid = createAID(keys.publicKey);

    await vault.storeIdentity("alice", {
      aid,
      privateKey: keys.privateKey,
      ksn: 0,
    });

    await expect(
      vault.decrypt("alice", "encrypted-data")
    ).rejects.toThrow("not yet implemented");
  });
});


================================================================================
SECTION 4: DOCUMENTATION
================================================================================

================================================================================
# cli/README.md
================================================================================

# Merits CLI

Command-line interface for Merits messaging system with KERI authentication.

## Quick Start

```bash
# Run all checks (tests + coverage) - default target
make

# Or explicitly
make check

# Run tests only
make test

# View help
make help
```

## Development

### Available Make Targets

- **`make`** or **`make check`** - Run tests + coverage report (default)
- **`make test`** - Run CLI unit tests
- **`make coverage`** - Generate HTML coverage report
- **`make typecheck`** - Type check (currently informational)
- **`make install`** - Install dependencies
- **`make clean`** - Remove generated files
- **`make summarise`** - Generate CLI summary and copy to clipboard
- **`make help`** - Show available targets

### Test Results

Current test coverage (Milestone 0):
- **41/41 tests passing** (100% success rate)
- **85.3% line coverage** overall
- **100% coverage** on config.ts
- **95.65% coverage** on OSKeychainVault.ts
- **86.71% coverage** on formatters.ts

### Project Structure

```
cli/
├── Makefile              # Development tasks
├── README.md            # This file
├── index.ts             # CLI entry point
├── lib/
│   ├── config.ts        # Configuration management
│   ├── context.ts       # CLI context
│   ├── formatters.ts    # Output formatters
│   ├── getAuthProof.ts  # Auth helper
│   └── vault/
│       ├── index.ts            # Vault factory
│       ├── MeritsVault.ts      # Vault interface
│       └── OSKeychainVault.ts  # OS Keychain implementation
└── tests/
    └── cli/unit/
        ├── config.test.ts      # Config tests
        ├── formatters.test.ts  # Formatter tests
        └── vault.test.ts       # Vault tests
```

## Usage

### Running the CLI

```bash
# From project root
bun run cli

# Show help
bun run cli --help

# Example commands (Milestone 1+)
bun run cli identity new alice
bun run cli identity list
bun run cli send --to bob --message "Hello!"
```

### Global Options

- `--format <json|text|compact>` - Output format (default: text)
- `--verbose` - Show detailed envelope data
- `--from <identity>` - Identity to use
- `--config <path>` - Config file path
- `--convex-url <url>` - Convex deployment URL
- `--no-color` - Disable colored output
- `--debug` - Enable debug logging

## Implementation Status

### ✅ Milestone 0 (Complete)

- [x] CLI framework (Commander.js)
- [x] MeritsVault interface
- [x] OSKeychainVault implementation
- [x] Config management (4-layer precedence)
- [x] Output formatters (JSON/text/compact)
- [x] Auth helper (`getAuthProof`)
- [x] Unit tests with 100% pass rate

### 🚧 Milestone 1 (Next)

- [ ] `identity new` - Generate new identity
- [ ] `identity list` - List all identities
- [ ] `identity show` - Show identity details
- [ ] `identity export` - Export private key
- [ ] `identity delete` - Delete identity
- [ ] Key rotation ceremony

### 📋 Milestone 2

- [ ] `send` - Send message
- [ ] `receive` - Receive messages
- [ ] Message encryption/decryption

### 📋 Milestone 3

- [ ] `watch` - Watch for incoming messages
- [ ] `group create` - Create group
- [ ] `group` commands - Group management
- [ ] Session tokens

## Architecture

### Vault Design

The vault uses a **pluggable architecture** with OS-native credential storage:

- **Primary**: OS Keychain (macOS/Linux/Windows)
- **Metadata**: `~/.merits/identities.json` (public data, 0600 permissions)
- **Principle**: Private keys never leave the vault
- **Caching**: Lazy-loaded metadata to reduce file I/O

### Config Management

4-layer precedence (highest to lowest):
1. CLI flags
2. Environment variables (`CONVEX_URL`, `MERITS_*`, `NO_COLOR`)
3. Config file (`~/.merits/config.json`)
4. Built-in defaults

### Auth Flow

1. Issue challenge via `client.identity.issueChallenge()`
2. Sign payload with vault (key stays in vault)
3. Return `AuthProof` with signature + challenge ID
4. Submit to mutation

## Dependencies

- **commander** - CLI framework
- **chalk** - Colored output
- **keytar** - OS keychain access
- **ajv** + **ajv-formats** - JSON schema validation
- **ora** - Spinners (future use)

## Documentation

- [CLI Design Plan](../docs/cli-plan.md)
- [Roadmap](../docs/roadmap-cli.md)
- [Milestone 0 Details](../docs/cli-phase-1.md)
- [Milestone 0 Complete](../docs/cli-milestone-0-complete.md)

## Contributing

### Adding New Commands

1. Add command definition in `cli/index.ts`
2. Create command handler in `cli/commands/<name>.ts`
3. Use `getContext(opts)` to access config/vault/client
4. Format output with `formatters.ts`
5. Add tests in `tests/cli/unit/<name>.test.ts`

### Running Tests

```bash
# Run tests
make test

# Watch mode (from project root)
cd .. && bun test --watch tests/cli/unit/

# Coverage
make coverage
open ../coverage/html/index.html
```

## License

See project root LICENSE file.


================================================================================
# docs/cli-phase-1.md
================================================================================

# CLI Milestone 0: Core Infrastructure

**Status**: 🔄 In Progress
**Started**: 2025-01-26
**Target Completion**: Week 1
**Actual Completion**: TBD

---

## Overview

Establish the foundational CLI framework, vault abstraction for secure credential management, configuration system, and output formatting. This milestone provides the infrastructure for all subsequent CLI features.

**Related Documentation**:
- [CLI Roadmap](./roadmap-cli.md) - Overall CLI development plan
- [CLI Design Plan](./cli-plan.md) - Comprehensive design
- [CLI Plan (Updated Review)](./merits-cli-plan-updated.md) - Auth optimizations

---

## Goals

### Primary Goals
1. ✅ Set up CLI framework with commander.js
2. ✅ Implement MeritsVault interface with OS Keychain integration
3. ✅ Create configuration management system
4. ✅ Build output formatters (json, text, compact)
5. ✅ Implement auth helper (`getAuthProof`)
6. ✅ Establish project structure

### Secondary Goals
- Unit tests for all core modules
- Documentation for each component
- Error handling patterns
- Logging infrastructure

---

## Architecture

### Project Structure

```
merits/
├── cli/
│   ├── index.ts                    # Entry point (#!/usr/bin/env bun)
│   ├── commands/                   # Command implementations (future)
│   ├── lib/
│   │   ├── vault/                  # Credential management
│   │   │   ├── MeritsVault.ts      # Interface definition
│   │   │   ├── OSKeychainVault.ts  # OS Keychain implementation
│   │   │   ├── EncryptedFileVault.ts # Fallback (future)
│   │   │   └── index.ts            # Vault factory
│   │   ├── getAuthProof.ts         # Challenge signing helper
│   │   ├── config.ts               # Config management
│   │   ├── formatters.ts           # Output formatting
│   │   └── client-factory.ts       # Create MeritsClient
│   └── types.ts                    # CLI-specific TypeScript types
├── tests/cli/
│   ├── unit/                       # Unit tests
│   └── integration/                # Integration tests (future)
└── package.json                    # Updated with CLI dependencies
```

---

## Deliverables

### 1. CLI Framework

**File**: `cli/index.ts`

**Purpose**: Entry point for the `merits` binary

**Implementation**:
```typescript
#!/usr/bin/env bun
import { Command } from 'commander';
import { version } from '../package.json';

const program = new Command();

program
  .name('merits')
  .description('Merits messaging CLI - KERI-authenticated secure messaging')
  .version(version);

// Global options
program
  .option('--format <type>', 'Output format (json|text|compact)', 'text')
  .option('--verbose', 'Show detailed envelope data', false)
  .option('--from <aid>', 'Identity to use')
  .option('--config <path>', 'Config file path', '~/.merits/config.json')
  .option('--no-color', 'Disable colored output')
  .option('--debug', 'Enable debug logging');

// Commands will be added in future milestones

program.parse();
```

**Features**:
- ✅ Shebang for direct execution
- ✅ Version flag
- ✅ Global options (format, verbose, etc.)
- ✅ Help text generation
- ✅ Argument parsing

---

### 2. MeritsVault Interface

**File**: `cli/lib/vault/MeritsVault.ts`

**Purpose**: Abstract interface for secure credential management

**Interface Definition**:
```typescript
/**
 * MeritsVault - Secure credential storage abstraction
 *
 * Isolates credential management from the CLI.
 * Private keys never leave the vault.
 */
export interface MeritsVault {
  /**
   * Store a new identity (securely stores private key)
   */
  storeIdentity(name: string, identity: {
    aid: string;
    privateKey: Uint8Array;
    ksn: number;
    metadata?: Record<string, any>;
  }): Promise<void>;

  /**
   * Retrieve identity metadata (NOT private key)
   */
  getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }>;

  /**
   * List all identity names
   */
  listIdentities(): Promise<string[]>;

  /**
   * Sign data with identity's private key
   * Returns KERI indexed signatures (e.g., "0-abc123...")
   * Key never leaves vault
   */
  signIndexed(name: string, data: Uint8Array): Promise<string[]>;

  /**
   * Decrypt ciphertext using identity's private key
   * Key never leaves vault
   */
  decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string>;

  /**
   * Export private key (requires confirmation/authentication)
   * Used for backup/transfer only
   */
  exportPrivateKey(name: string): Promise<Uint8Array>;

  /**
   * Delete an identity
   */
  deleteIdentity(name: string): Promise<void>;
}
```

**Design Principles**:
- 🔐 Private keys never exposed directly
- 🔑 Signing happens inside vault
- 📦 Decryption happens inside vault
- 🧩 Future-proof for multisig (indexed signatures)

---

### 3. OS Keychain Vault Implementation

**File**: `cli/lib/vault/OSKeychainVault.ts`

**Purpose**: Primary vault implementation using OS native credential storage

**Dependencies**:
```json
{
  "keytar": "^7.9.0"  // Cross-platform OS keychain access
}
```

**Implementation**:
```typescript
import * as keytar from 'keytar';
import { sign, verify } from '../../../core/crypto';
import type { MeritsVault } from './MeritsVault';

const SERVICE_NAME = 'com.merits.cli';

/**
 * OSKeychainVault - Stores private keys in OS credential store
 *
 * - macOS: Keychain
 * - Linux: Secret Service API (libsecret)
 * - Windows: Credential Manager
 */
export class OSKeychainVault implements MeritsVault {
  private metadataPath: string;
  private metadata: IdentityMetadata;

  constructor(metadataPath = '~/.merits/identities.json') {
    this.metadataPath = expandPath(metadataPath);
    this.metadata = this.loadMetadata();
  }

  async storeIdentity(name: string, identity: {
    aid: string;
    privateKey: Uint8Array;
    ksn: number;
    metadata?: Record<string, any>;
  }): Promise<void> {
    // Store private key in OS keychain
    const privateKeyHex = Buffer.from(identity.privateKey).toString('hex');
    await keytar.setPassword(SERVICE_NAME, name, privateKeyHex);

    // Store metadata in JSON file (public data only)
    this.metadata.identities[name] = {
      aid: identity.aid,
      ksn: identity.ksn,
      name,
      createdAt: Date.now(),
      vaultProvider: 'os-keychain',
      metadata: identity.metadata
    };

    await this.saveMetadata();
  }

  async getIdentity(name: string): Promise<{
    aid: string;
    ksn: number;
    metadata?: Record<string, any>;
  }> {
    const identity = this.metadata.identities[name];
    if (!identity) {
      throw new Error(`Identity not found: ${name}`);
    }

    return {
      aid: identity.aid,
      ksn: identity.ksn,
      metadata: identity.metadata
    };
  }

  async listIdentities(): Promise<string[]> {
    return Object.keys(this.metadata.identities);
  }

  async signIndexed(name: string, data: Uint8Array): Promise<string[]> {
    const privateKey = await this.getPrivateKey(name);
    const signature = await sign(data, privateKey);

    // Create indexed signature (format: "0-base64sig")
    const sigBase64 = uint8ArrayToBase64Url(signature);
    return [`0-${sigBase64}`];
  }

  async decrypt(
    name: string,
    ct: string,
    opts?: { ek?: string; alg?: string }
  ): Promise<string> {
    const privateKey = await this.getPrivateKey(name);

    // For now: simple base64 decoding (mock decryption)
    // Future: X25519 + XChaCha20-Poly1305
    return Buffer.from(ct, 'base64').toString('utf-8');
  }

  async exportPrivateKey(name: string): Promise<Uint8Array> {
    // This should prompt for OS authentication (Touch ID, etc.)
    const privateKey = await this.getPrivateKey(name);
    return privateKey;
  }

  async deleteIdentity(name: string): Promise<void> {
    await keytar.deletePassword(SERVICE_NAME, name);
    delete this.metadata.identities[name];
    await this.saveMetadata();
  }

  // Private helper
  private async getPrivateKey(name: string): Promise<Uint8Array> {
    const privateKeyHex = await keytar.getPassword(SERVICE_NAME, name);
    if (!privateKeyHex) {
      throw new Error(`Private key not found for: ${name}`);
    }
    return Buffer.from(privateKeyHex, 'hex');
  }

  private loadMetadata(): IdentityMetadata {
    if (!fs.existsSync(this.metadataPath)) {
      return { version: 1, defaultIdentity: null, identities: {} };
    }
    return JSON.parse(fs.readFileSync(this.metadataPath, 'utf-8'));
  }

  private async saveMetadata(): Promise<void> {
    const dir = path.dirname(this.metadataPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    fs.writeFileSync(
      this.metadataPath,
      JSON.stringify(this.metadata, null, 2),
      { mode: 0o600 }
    );
  }
}
```

**Security Features**:
- ✅ Private keys stored in OS keychain (encrypted by OS)
- ✅ Touch ID / Windows Hello integration (OS-level)
- ✅ Metadata file permissions: 0600 (owner only)
- ✅ No plaintext keys on disk
- ✅ Signing happens in-process (keys retrieved only for operation)

---

### 4. Vault Factory

**File**: `cli/lib/vault/index.ts`

**Purpose**: Auto-detect best vault for platform

**Implementation**:
```typescript
import { OSKeychainVault } from './OSKeychainVault';
import type { MeritsVault } from './MeritsVault';

/**
 * Check if OS keychain is available
 */
function isOSKeychainAvailable(): boolean {
  try {
    require.resolve('keytar');
    return true;
  } catch {
    return false;
  }
}

/**
 * Create vault instance (auto-detect best available)
 */
export function createVault(config?: {
  metadataPath?: string;
}): MeritsVault {
  if (isOSKeychainAvailable()) {
    return new OSKeychainVault(config?.metadataPath);
  }

  // Fallback to encrypted file vault (future)
  console.warn('⚠ OS keychain not available, using encrypted file vault');
  throw new Error('EncryptedFileVault not yet implemented');
}

export type { MeritsVault };
export { OSKeychainVault };
```

---

### 5. Auth Helper

**File**: `cli/lib/getAuthProof.ts`

**Purpose**: Unified helper for KERI challenge signing

**Implementation**:
```typescript
import type { MeritsClient } from '../../src/client';
import type { MeritsVault } from './vault/MeritsVault';
import type { AuthProof } from '../../core/types';

/**
 * Get authentication proof for a Merits operation
 *
 * Handles the complete challenge/response flow:
 * 1. Issue challenge from server
 * 2. Sign payload with vault
 * 3. Return AuthProof
 *
 * @example
 * const auth = await getAuthProof({
 *   client,
 *   vault,
 *   identityName: "alice",
 *   purpose: "send",
 *   args: { recpAid: bobAid, ctHash: "abc123", ttl: 60000 }
 * });
 */
export async function getAuthProof(params: {
  client: MeritsClient;
  vault: MeritsVault;
  identityName: string;
  purpose: 'send' | 'receive' | 'ack' | 'receiveAndAck' | 'admin' | 'manageGroup';
  args?: Record<string, unknown>;
}): Promise<AuthProof> {
  const { client, vault, identityName, purpose, args = {} } = params;

  // Get identity metadata
  const identity = await vault.getIdentity(identityName);

  // Issue challenge
  const challenge = await client.identity.issueChallenge({
    aid: identity.aid,
    purpose: purpose as any,
    args
  });

  // Canonical JSON encoding for signing
  const canonical = JSON.stringify(
    challenge.payloadToSign,
    Object.keys(challenge.payloadToSign).sort()
  );
  const data = new TextEncoder().encode(canonical);

  // Sign with vault (key never leaves vault)
  const sigs = await vault.signIndexed(identityName, data);

  return {
    challengeId: challenge.challengeId,
    sigs,
    ksn: identity.ksn
  };
}
```

**Benefits**:
- ✅ Single point for all auth flows
- ✅ Consistent canonical JSON encoding
- ✅ Type-safe purpose parameter
- ✅ Vault abstraction (works with any vault implementation)

---

### 6. Configuration Management

**File**: `cli/lib/config.ts`

**Purpose**: Load/save configuration with precedence

**Config Format** (`~/.merits/config.json`):
```json
{
  "version": 1,
  "convexUrl": "https://accurate-penguin-901.convex.cloud",
  "defaultIdentity": "alice",
  "outputFormat": "text",
  "watchInterval": 1000,
  "autoMarkRead": true,
  "verboseByDefault": false
}
```

**Implementation**:
```typescript
import * as fs from 'fs';
import * as path from 'path';

export interface MeritsConfig {
  version: number;
  convexUrl?: string;
  defaultIdentity?: string;
  outputFormat?: 'json' | 'text' | 'compact';
  watchInterval?: number;
  autoMarkRead?: boolean;
  verboseByDefault?: boolean;
}

const DEFAULT_CONFIG: MeritsConfig = {
  version: 1,
  outputFormat: 'text',
  watchInterval: 1000,
  autoMarkRead: true,
  verboseByDefault: false
};

/**
 * Load configuration with precedence:
 * 1. CLI flags (passed as overrides)
 * 2. Environment variables
 * 3. Config file
 * 4. Built-in defaults
 */
export function loadConfig(
  configPath = '~/.merits/config.json',
  overrides: Partial<MeritsConfig> = {}
): MeritsConfig {
  const expandedPath = expandPath(configPath);

  // Start with defaults
  let config = { ...DEFAULT_CONFIG };

  // Layer 3: Config file
  if (fs.existsSync(expandedPath)) {
    const fileConfig = JSON.parse(fs.readFileSync(expandedPath, 'utf-8'));
    config = { ...config, ...fileConfig };
  }

  // Layer 2: Environment variables
  const envConfig: Partial<MeritsConfig> = {
    convexUrl: process.env.MERITS_CONVEX_URL || process.env.CONVEX_URL,
    defaultIdentity: process.env.MERITS_DEFAULT_IDENTITY,
    outputFormat: process.env.MERITS_FORMAT as any
  };
  config = { ...config, ...envConfig };

  // Layer 1: CLI overrides
  config = { ...config, ...overrides };

  return config;
}

/**
 * Save configuration to file
 */
export function saveConfig(
  config: MeritsConfig,
  configPath = '~/.merits/config.json'
): void {
  const expandedPath = expandPath(configPath);
  const dir = path.dirname(expandedPath);

  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }

  fs.writeFileSync(
    expandedPath,
    JSON.stringify(config, null, 2),
    { mode: 0o600 }
  );
}

function expandPath(p: string): string {
  if (p.startsWith('~/')) {
    return path.join(process.env.HOME || '~', p.slice(2));
  }
  return p;
}
```

**Precedence Example**:
```bash
# Config file: outputFormat = "text"
# Env var: MERITS_FORMAT=json
# CLI flag: --format compact

# Result: "compact" (CLI flag wins)
```

---

### 7. Output Formatters

**File**: `cli/lib/formatters.ts`

**Purpose**: Consistent output formatting across all commands

**Implementation**:
```typescript
import chalk from 'chalk';
import type { EncryptedMessage } from '../../core/interfaces/Transport';

export type OutputFormat = 'json' | 'text' | 'compact';

/**
 * Format messages for display
 */
export function formatMessages(
  messages: EncryptedMessage[],
  format: OutputFormat,
  verbose = false
): string {
  switch (format) {
    case 'json':
      return formatJSON(messages, verbose);
    case 'text':
      return formatText(messages, verbose);
    case 'compact':
      return formatCompact(messages);
    default:
      throw new Error(`Unknown format: ${format}`);
  }
}

/**
 * JSON format - machine-readable
 */
function formatJSON(messages: EncryptedMessage[], verbose: boolean): string {
  if (verbose) {
    return JSON.stringify(messages, null, 2);
  }

  // Minimal JSON (exclude senderProof unless verbose)
  const minimal = messages.map(m => ({
    id: m.id,
    from: m.from,
    to: m.to,
    ct: m.ct,
    typ: m.typ,
    createdAt: m.createdAt,
    expiresAt: m.expiresAt
  }));

  return JSON.stringify(minimal, null, 2);
}

/**
 * Text format - human-readable with colors
 */
function formatText(messages: EncryptedMessage[], verbose: boolean): string {
  const lines: string[] = [];

  lines.push(chalk.bold(`${messages.length} message(s)\n`));

  for (const msg of messages) {
    lines.push(chalk.cyan(`From: ${msg.from}`));
    lines.push(chalk.cyan(`To: ${msg.to}`));
    lines.push(`Type: ${msg.typ || 'unknown'}`);
    lines.push(`Time: ${new Date(msg.createdAt).toLocaleString()}`);

    if (verbose) {
      lines.push(`Expires: ${new Date(msg.expiresAt).toLocaleString()}`);
      lines.push('');
      lines.push(chalk.gray('Envelope:'));
      lines.push(chalk.gray(`  ID: ${msg.id}`));
      lines.push(chalk.gray(`  Hash: ${msg.envelopeHash}`));
      lines.push('');
      lines.push(chalk.gray('Sender Proof:'));
      lines.push(chalk.gray(`  KSN: ${msg.senderProof.ksn}`));
      lines.push(chalk.gray(`  Signature: ${msg.senderProof.sigs[0]}`));
    }

    lines.push('');
    lines.push(chalk.white(msg.ct)); // Will be decrypted plaintext in future
    lines.push('');
    lines.push(chalk.gray('---'));
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Compact format - one line per message
 */
function formatCompact(messages: EncryptedMessage[]): string {
  return messages.map(msg => {
    const time = new Date(msg.createdAt).toLocaleTimeString();
    const from = truncateAID(msg.from);
    const to = truncateAID(msg.to);
    const content = msg.ct.substring(0, 50); // Preview
    return `[${time}] ${from}→${to}: ${content}`;
  }).join('\n');
}

/**
 * Truncate AID for compact display
 */
function truncateAID(aid: string, length = 8): string {
  if (aid.length <= length) return aid;
  return aid.substring(0, length) + '...';
}
```

**Output Examples**:

**JSON**:
```json
[
  {
    "id": "j5768kc28d1gwe1f9n24xnneyn7t2vbq",
    "from": "DHytGsw0r-wYg0DSf_4l_D594hXtKH_e5-zMIdlM",
    "to": "DXaNTrBG50YwcTLZw2YCkCmKNl2cELpuH-EjDCmdCaXU",
    "ct": "SGVsbG8gQWxpY2Uh",
    "typ": "chat.text.v1",
    "createdAt": 1705329322000,
    "expiresAt": 1705415722000
  }
]
```

**Text**:
```
1 message(s)

From: DHytGsw0r-wYg0DSf_4l_D594hXtKH_e5-zMIdlM
To: DXaNTrBG50YwcTLZw2YCkCmKNl2cELpuH-EjDCmdCaXU
Type: chat.text.v1
Time: 1/15/2024, 2:35:22 PM

Hello Alice!

---
```

**Compact**:
```
[14:35:22] DHytGsw0...→DXaNTrBG... Hello Alice!
```

---

## Testing

### Unit Tests

**Location**: `tests/cli/unit/`

**Coverage**:

1. **Vault Tests** (`vault.test.ts`):
```typescript
test("store and retrieve identity metadata", async () => {
  const vault = createVault();

  await vault.storeIdentity("alice", {
    aid: "DHytG...",
    privateKey: new Uint8Array(32),
    ksn: 0
  });

  const identity = await vault.getIdentity("alice");
  expect(identity.aid).toBe("DHytG...");
  expect(identity.ksn).toBe(0);
});

test("sign data with vault", async () => {
  const vault = createVault();
  const data = new TextEncoder().encode("test");

  const sigs = await vault.signIndexed("alice", data);
  expect(sigs).toHaveLength(1);
  expect(sigs[0]).toMatch(/^0-/); // Indexed signature format
});
```

2. **Config Tests** (`config.test.ts`):
```typescript
test("load config with precedence", () => {
  const config = loadConfig('~/.merits/config.json', {
    outputFormat: 'json'
  });

  expect(config.outputFormat).toBe('json'); // Override wins
});
```

3. **Formatter Tests** (`formatters.test.ts`):
```typescript
test("format messages as JSON", () => {
  const messages = [{ id: "msg1", from: "alice", ... }];
  const output = formatMessages(messages, 'json');

  expect(() => JSON.parse(output)).not.toThrow();
});
```

4. **Auth Helper Tests** (`getAuthProof.test.ts`):
```typescript
test("getAuthProof returns valid proof", async () => {
  const proof = await getAuthProof({
    client: mockClient,
    vault: mockVault,
    identityName: "alice",
    purpose: "send",
    args: { recpAid: "bob" }
  });

  expect(proof.challengeId).toBeDefined();
  expect(proof.sigs).toHaveLength(1);
  expect(proof.ksn).toBe(0);
});
```

---

## Success Criteria

### Functional
- ✅ CLI boots with `merits --help`
- ✅ Can create vault and store credentials
- ✅ Can load/save config with precedence
- ✅ Can format output in json/text/compact
- ✅ Can sign challenges via vault
- ✅ All unit tests passing

### Security
- ✅ Private keys stored in OS keychain
- ✅ Metadata file has 0600 permissions
- ✅ Keys never exposed in plaintext
- ✅ Signing happens inside vault

### Code Quality
- ✅ TypeScript strict mode
- ✅ All interfaces documented
- ✅ Error handling consistent
- ✅ Logging infrastructure ready

---

## Dependencies Added

```json
{
  "dependencies": {
    "commander": "^11.1.0",
    "chalk": "^5.3.0",
    "ora": "^8.0.1",
    "keytar": "^7.9.0"
  }
}
```

---

## Next Steps

After Milestone 0 completion:
1. Create completion document
2. Begin Milestone 1 (Identity Management)
3. Implement `merits init` command
4. Implement `merits id:*` commands

---

**Status**: 🔄 In Progress
**Completion**: TBD
**Next Milestone**: [Milestone 1: Identity Management](./roadmap-cli.md#milestone-1-identity-management)


================================================================================
# docs/cli-milestone-0-complete.md
================================================================================

# CLI Milestone 0 - Complete ✅

**Status**: All deliverables implemented and tested
**Test Results**: 41 unit tests passing (100% success rate)
**Date Completed**: 2025-10-26

## Summary

Successfully implemented the foundational infrastructure for the Merits CLI, including:

1. ✅ **CLI Framework** - Commander.js with preAction/postAction hooks
2. ✅ **MeritsVault Interface** - Pluggable credential storage abstraction
3. ✅ **OSKeychainVault** - OS-native keychain integration with metadata caching
4. ✅ **Config Management** - 4-layer precedence with schema validation
5. ✅ **Async Formatters** - JSON/text/compact output with future vault decryption support
6. ✅ **Auth Helper** - `getAuthProof()` with forward-compatible types
7. ✅ **Unit Tests** - 41 tests including error paths and snapshot tests

## Files Created

### Core Infrastructure

```
cli/
├── index.ts                     # CLI entry point with commander
├── lib/
│   ├── context.ts              # CLI context interface
│   ├── config.ts               # Config management (243 lines)
│   ├── formatters.ts           # Output formatters (284 lines)
│   ├── getAuthProof.ts         # Auth helper (108 lines)
│   └── vault/
│       ├── MeritsVault.ts      # Vault interface (123 lines)
│       ├── OSKeychainVault.ts  # OS Keychain implementation (279 lines)
│       └── index.ts            # Vault factory (49 lines)
```

### Tests

```
tests/cli/unit/
├── config.test.ts              # 13 tests for config management
├── vault.test.ts               # 13 tests for vault operations
├── formatters.test.ts          # 15 tests with snapshots
└── __snapshots__/
    └── formatters.test.ts.snap # 13 golden output snapshots
```

## Test Results

```
✓ Config Management:          13/13 tests passing
✓ OSKeychainVault:            13/13 tests passing
✓ Formatters (with snapshots): 15/15 tests passing
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Total:                        41/41 tests passing
Snapshots:                    13 snapshots created
Execution Time:               273ms
```

## Implementation Highlights

### 1. CLI Framework

**File**: [cli/index.ts](../cli/index.ts)

- Commander.js with preAction hook for centralized context setup
- Global options: `--format`, `--verbose`, `--from`, `--config`, `--convex-url`, `--no-color`, `--debug`
- PostAction hook for cleanup (vault flush + client close)
- Placeholder commands for future milestones

**Example Usage**:
```bash
bun run cli/index.ts --help
bun run cli/index.ts identity --verbose
```

### 2. MeritsVault Interface

**File**: [cli/lib/vault/MeritsVault.ts](../cli/lib/vault/MeritsVault.ts)

- **Design Principle**: Private keys never leave the vault
- All crypto operations (signing, decryption) happen inside vault
- Methods: `storeIdentity`, `getIdentity`, `listIdentities`, `signIndexed`, `decrypt`, `exportPrivateKey`, `deleteIdentity`, `flush`
- `VaultError` class with typed error codes

### 3. OSKeychainVault

**File**: [cli/lib/vault/OSKeychainVault.ts](../cli/lib/vault/OSKeychainVault.ts)

**Features**:
- Stores private keys in OS credential store (macOS Keychain, Linux Secret Service, Windows Credential Manager)
- Metadata in `~/.merits/identities.json` (secure permissions: 0600)
- Lazy-loading with metadata caching to reduce file I/O
- Flush-on-dirty pattern with `setupFlushOnExit` helper

**Implementation**:
- Service name: `com.merits.cli`
- Uses `keytar` library for cross-platform OS keychain access
- Private keys stored as base64 in keychain
- Public metadata (AID, KSN, custom fields) stored in JSON file

### 4. Config Management

**File**: [cli/lib/config.ts](../cli/lib/config.ts)

**4-Layer Precedence**:
1. CLI flags (highest priority)
2. Environment variables (`CONVEX_URL`, `MERITS_*`, `NO_COLOR`)
3. Config file (`~/.merits/config.json`)
4. Defaults (lowest priority)

**Schema Validation**:
- Uses Ajv with `ajv-formats` plugin
- Validates types, enums, ranges
- Clear error messages with all validation failures

**Security**:
- Config file created with 0600 permissions
- Config directory created with 0700 permissions

### 5. Async Formatters

**File**: [cli/lib/formatters.ts](../cli/lib/formatters.ts)

**Formats**:
- `json` - Machine-readable (minimal or verbose)
- `text` - Human-readable with color support
- `compact` - One-line-per-item

**Functions**:
- `formatMessages()` - Format encrypted messages
- `formatIdentity()` - Format identity details
- `formatGroup()` - Format group details

**Future-Proof**:
- All formatters are async for future vault decryption
- Accept optional `vault` + `identityName` for auto-decryption
- Color support via `chalk` (respects `--no-color` flag)

### 6. Auth Helper

**File**: [cli/lib/getAuthProof.ts](../cli/lib/getAuthProof.ts)

**Main Function**: `getAuthProof()`
- Simplifies authentication for CLI commands
- Uses vault for signing (key never exported)
- Canonical JSON encoding for deterministic signatures

**Forward-Compatible Types**:
- `AuthPurpose` includes future purposes: `receiveAndAck`, `openSession`
- Placeholder functions: `getSessionToken()`, `getReceiveAndAckProof()`
- Will be implemented in Milestone 3

### 7. Unit Tests

**Coverage**:
- ✅ Config: All precedence layers, validation, error handling
- ✅ Vault: Store/retrieve, list, sign, delete, error paths, metadata caching
- ✅ Formatters: All formats, verbose mode, color mode, snapshot tests

**Error Path Tests**:
- Missing config values
- Invalid schema
- Duplicate identities
- Nonexistent identities
- Malformed JSON
- Unknown formats

**Snapshot Tests**:
- 13 golden output snapshots for formatters
- Ensures consistent output across refactors

## Dependencies Added

```json
{
  "dependencies": {
    "commander": "^11.1.0",    // CLI framework
    "chalk": "^5.3.0",         // Colored output
    "ora": "^8.0.1",           // Spinners (future use)
    "keytar": "^7.9.0",        // OS keychain access
    "ajv": "^8.12.0",          // JSON schema validation
    "ajv-formats": "^3.0.1"    // Format validators (uri, etc.)
  }
}
```

## Architecture Decisions

### 1. Pluggable Vault Design

- Interface-based architecture allows multiple vault implementations
- Factory function (`createVault`) for easy instantiation
- Future: Add `EncryptedFileVault` for headless systems

### 2. Lazy Metadata Loading

- Metadata loaded on first access, not at vault creation
- Reduces startup time for commands that don't need vault
- Flush-on-dirty pattern minimizes writes

### 3. Centralized Context

- PreAction hook creates config/vault/client once
- Injected into command options as `_ctx`
- DRY principle - no duplication across commands

### 4. Forward-Compatible Auth Types

- `AuthPurpose` type includes future purposes
- Placeholder functions throw helpful errors
- No breaking changes when adding session tokens in Milestone 3

## Success Criteria - All Met ✅

- [x] CLI runs with `--help` and shows usage
- [x] Config loads from all 4 precedence layers
- [x] Config validates against schema
- [x] Vault stores and retrieves identities
- [x] Vault stores private keys in OS keychain
- [x] Vault metadata cached and flushed on demand
- [x] Formatters produce correct output for all 3 modes
- [x] Formatters support async signatures
- [x] Auth helper creates valid proofs
- [x] 41 unit tests pass (100% success rate)
- [x] Snapshot tests verify formatter output

## Next Steps - Milestone 1

See [cli-phase-2.md](cli-phase-2.md) (when created) for:

1. **Identity Commands**:
   - `merits identity new` - Generate new identity
   - `merits identity list` - List all identities
   - `merits identity show` - Show identity details
   - `merits identity export` - Export private key
   - `merits identity delete` - Delete identity

2. **Key Rotation**:
   - Generate rotation event
   - Update keystate on server
   - Migrate to new KSN

3. **Integration Tests**:
   - End-to-end identity management flows
   - Key rotation scenarios

## Notes

- All 7 refinements from [cli-milestone-0-refinements.md](cli-milestone-0-refinements.md) implemented
- Achieved 100% completion as specified in requirements
- Ready to proceed to Milestone 1 (Identity Management)

---

**Milestone 0 Complete** 🎉
All foundational infrastructure in place for building CLI commands.


